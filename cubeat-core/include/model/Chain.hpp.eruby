
<% header_guard do %>

#include "utils/math.hpp"
#include "utils/ObjectPool.hpp"
#include <boost/tr1/memory.hpp>
#include <vector>

namespace psc{ namespace model{

class Chain{
public:
    typedef std::tr1::shared_ptr<Chain> pointer_type;
    typedef std::tr1::weak_ptr<Chain> wpointer_type;
    static pointer_type create(){ return utils::ObjectPool<Chain>::create(); }
    static pointer_type create(pointer_type const& that){ return utils::ObjectPool<Chain>::create(that); }

public:
    int last_step_amounts() const{ return chain_step_.back(); }
    int step_amounts(int const& step) const{ return chain_step_[step-1]; }

    // map will be responsible to notify Chain to push new elements to Chains.
    void add_last_step_amounts(int const& num){
        add_step_amounts(step(), num);
    }

    void add_step_amounts(int const& step, int const& num) {
        chain_step_[step-1] += num;
        step_indices_.push_back(step);
    }

    void step_one(){
        chain_step_.push_back(0);
        power_step_.push_back(0);
    }

    int power_factor() const{
        int res = 0;
        for( size_t i = 0; i < power_step_.size(); ++i ) {
            res += power_step_[i];
        }
        return res;
    }

    void update_power_factor() {
        update_power_factor_step(chain_step_.size());
//        int new_step_amount = chain_step_.back();
//        if( new_step_amount < 3 ) return;
//        int stepnum = chain_step_.size();
//        if( stepnum == 1 ) {
//            // power_factor_ += (new_step_amount - 2);
//            if( new_step_amount > 3 ) {
//                power_step_.back() = (new_step_amount - 1);
//            }
//        }
//        else {
//            power_step_.back() = (new_step_amount - 1)*(stepnum)/2 + (stepnum-1);
//            //power_factor_ += (new_step_amount - 1)/2*(stepnum) + (stepnum-2);
//            //power_factor_ += (new_step_amount - 1)/2*(stepnum) + (stepnum-2)*2;
//            //power_factor_ += (new_step_amount - 2)*(stepnum);
//            //power_factor_ += (new_step_amount - 1)/2*(stepnum) + utils::power2(stepnum-2);
//            //power_factor_ += (new_step_amount - 1)*(stepnum) + utils::power2(stepnum-2);
//        }
    }

    void update_power_factor_step(int const& step) {
        int step_amount = chain_step_[step-1];
        int stepnum = step; //This is for specific step, not the last step of a chain
        if( stepnum == 1 ) {
            if( step_amount > 3 ) {
                power_step_[step-1] = step_amount - 1;
            }
        }
        else {
            power_step_[step-1] = (step_amount - 1)*(stepnum)/2 + (stepnum-1);
        }
    }

    int step_score(int const& step) const{
        return attack_of_step(step) * 50;
    }

    int step() const{
        return chain_step_.size();
    }

    int attack_of_current_step() const {
        return power_step_.back();
    }

    int attack_of_step(int step) const {
        return power_step_[step-1];
    }

    int step_indices_size() const {
        return step_indices_.size();
    }

    int step_indices(int const& i) const {
        return step_indices_[i];
    }

    void clear_indices() {
        step_indices_.clear();
    }

    bool is_extending_final_step() const { return is_extending_final_step_; }
    void is_extending_final_step(bool i) { is_extending_final_step_ = i; }

    Chain(): is_extending_final_step_(false) {}

    Chain(pointer_type const& that):
        chain_step_(that->chain_step_),
        power_step_(that->power_step_),
        step_indices_(that->step_indices_),
        is_extending_final_step_(that->is_extending_final_step_)
    {}

private:
    std::vector<int> chain_step_;
    std::vector<int> power_step_;
    std::vector<int> step_indices_;
    bool is_extending_final_step_;
};

typedef Chain::pointer_type pChain;
typedef Chain::wpointer_type wpChain;

}} // end of namespace

<% end %>
