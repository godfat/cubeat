
<% header_guard do %>

#include "utils/math.hpp"
#include "utils/ObjectPool.hpp"
#include <boost/tr1/memory.hpp>
#include <vector>
#include <list>
#include <set>

#include <cstdio>


namespace psc{ namespace model{

class Chain{
public:
    typedef std::tr1::shared_ptr<Chain> pointer_type;
    typedef std::tr1::weak_ptr<Chain> wpointer_type;
    static pointer_type create(int chain_amounts = 3){ return utils::ObjectPool<Chain>::create(chain_amounts); }
    static pointer_type create(pointer_type const& that){ return utils::ObjectPool<Chain>::create(that); }

public:
    int last_step_amounts() const{ return chain_step_.back(); }
    int step_amounts(int const& step) const{ return chain_step_[step-1]; }

    // map will be responsible to notify Chain to push new elements to Chains.
    void add_last_step_amounts(int const& num){
        add_step_amounts(step(), num);
    }

    void add_step_amounts(int const& step, int const& num) {
        chain_step_[step-1] += num;
        step_indices_.insert(step);
    }

    void add_step_cube(int step, int x, int y) {
        step_group_[step-1].push_back( std::make_pair(x, y) );
    }

    void remove_step_cube(int step, int x, int y) {
        step_group_[step-1].remove( std::make_pair(x, y) );
    }

    std::list< std::pair<int, int> > const & get_step_group(int step) {
        return step_group_[step-1];
    }

    void step_one(){
        chain_step_.push_back(0);
        power_step_.push_back(0);
        is_step_extending_.push_back(false);
        step_group_.push_back( std::list< std::pair<int, int> >() );
    }

    int power_factor() const{
        int res = 0;
        for( size_t i = 0; i < power_step_.size(); ++i ) {
            res += power_step_[i];
        }
        return res;
    }

    void update_power_factor() {
        update_power_factor_step(chain_step_.size());
//        int new_step_amount = chain_step_.back();
//        if( new_step_amount < 3 ) return;
//        int stepnum = chain_step_.size();
//        if( stepnum == 1 ) {
//            // power_factor_ += (new_step_amount - 2);
//            if( new_step_amount > 3 ) {
//                power_step_.back() = (new_step_amount - 1);
//            }
//        }
//        else {
//            power_step_.back() = (new_step_amount - 1)*(stepnum)/2 + (stepnum-1);
//            //power_factor_ += (new_step_amount - 1)/2*(stepnum) + (stepnum-2);
//            //power_factor_ += (new_step_amount - 1)/2*(stepnum) + (stepnum-2)*2;
//            //power_factor_ += (new_step_amount - 2)*(stepnum);
//            //power_factor_ += (new_step_amount - 1)/2*(stepnum) + utils::power2(stepnum-2);
//            //power_factor_ += (new_step_amount - 1)*(stepnum) + utils::power2(stepnum-2);
//        }
    }

    void update_power_factor_step(int const& step) {
        int step_amount = chain_step_[step-1];
        int stepnum = step; //This is for specific step, not the last step of a chain
        if( stepnum == 1 ) {
            if( step_amount > chain_amounts_ ) { // notice the strictly-greater sign.
                power_step_[step-1] = step_amount;
            } else {
                power_step_[step-1] = 0;
                // 2014.6 To cope with chain merge problem, it's totally possible for "weaker" chains to be
                //        absorbed and cleaned out of its attack power, so have to consider it here.
            }
        }
        else {
            if( step_amount >= chain_amounts_ ) { // notice the greater-equal sign.
                power_step_[step-1] = (step_amount) /* *(stepnum)/2 */ + (stepnum);
            } else {
                power_step_[step-1] = 0;
            }
        }
    }

    int step_score(int const& step) const{
        return attack_of_step(step) * 50;
    }

    int step() const{
        return chain_step_.size();
    }

    int attack_of_current_step() const {
        return power_step_.back();
    }

    int attack_of_step(int step) const {
        return power_step_[step-1];
    }

    std::set<int> const& step_indices() const {
        return step_indices_;
    }

    void set_extending(int step, bool flag) {
        is_step_extending_[step-1] = flag;
    }

    bool is_step_extending(int step) const {
        return is_step_extending_[step-1];
    }

    void clear_indices() {
        step_indices_.clear();
    }

    void debugging_print() {
        printf("Chain %x (updated indices: ", this);
        for( std::set<int>::iterator i = step_indices_.begin(), iend = step_indices_.end(); i != iend; ++i ) {
            printf("%d ", *i);
        }
        printf(")\n");
        for( size_t i = 0; i < chain_step_.size(); ++i ) {
            printf("  - step %d / %d cubes / power %d / extending %d: ", i+1, chain_step_[i], power_step_[i], static_cast<int>(is_step_extending_[i]));
            for( std::list< std::pair<int, int> >::iterator j = step_group_[i].begin(), jend = step_group_[i].end(); j != jend; ++j ) {
                printf("(%d,%d) ", j->first, j->second);
            }
            printf("\n");
        }
        printf("\n");
    }

    Chain(int chain_amounts):
        chain_amounts_(chain_amounts) {}

    Chain(pointer_type const& that):
        chain_amounts_(that->chain_amounts_),
        chain_step_(that->chain_step_),
        power_step_(that->power_step_),
        step_indices_(that->step_indices_),
        is_step_extending_(that->is_step_extending_),
        step_group_(that->step_group_)
    {}

private:
    int  chain_amounts_;
    std::vector<int> chain_step_;
    std::vector<int> power_step_;
    std::set<int>    step_indices_;
    std::vector<bool> is_step_extending_;
    std::vector< std::list< std::pair<int, int> > > step_group_;
};

typedef Chain::pointer_type pChain;
typedef Chain::wpointer_type wpChain;

}} // end of namespace

<% end %>
