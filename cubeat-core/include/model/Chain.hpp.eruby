
<% header_guard do %>

#include "utils/math.hpp"
#include "utils/ObjectPool.hpp"
#include <boost/tr1/memory.hpp>
#include <vector>

namespace psc{ namespace model{

class Chain{
public:
    typedef std::tr1::shared_ptr<Chain> pointer_type;
    typedef std::tr1::weak_ptr<Chain> wpointer_type;
    static pointer_type create() {
        return utils::ObjectPoolRestorable<Chain>::create();
        //return utils::ObjectPool<Chain>::create();
    }
    static pointer_type create(pointer_type const& that) {
        return utils::ObjectPoolRestorable<Chain>::create(that);
        //return utils::ObjectPool<Chain>::create(that);
    }

public:
    int last_step_amounts() const;
    void add_last_step_amounts(int num);
    void step_one();
    int power_factor() const;
    void update_power_factor();

    // this returns the score fragment made by the last combo
    int score_step() const;
    int step() const;

    void set_last_step_position(int x, int y);
    int last_step_x() const;
    int last_step_y() const;
    int attack_of_current_step() const;

    Chain();
    Chain(pointer_type const& that);
    ~Chain();

private:
    /// WTF NOTE TO SELF: This will be a problem when rolling back.
    //  unless the container is stationary or fixed during the life time of this object, (which is rarely likely)
    //  we can't have a persistent, not-rollbackable std container inside a rollbackable object.
    std::vector<int> chain_step_;

    int last_step_x_, last_step_y_;
    int power_factor_, last_power_factor_;
    // int damage_factor_;
};

typedef Chain::pointer_type pChain;
typedef Chain::wpointer_type wpChain;

}} // end of namespace

<% end %>
