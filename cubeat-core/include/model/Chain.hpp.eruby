
<% header_guard do %>

#include "utils/math.hpp"
#include "utils/ObjectPool.hpp"
#include <boost/tr1/memory.hpp>
#include <vector>
#include <list>
#include <set>


namespace psc{ namespace model{

class Chain{
public:
    typedef std::tr1::shared_ptr<Chain> pointer_type;
    typedef std::tr1::weak_ptr<Chain> wpointer_type;
    static pointer_type create(){ return utils::ObjectPool<Chain>::create(); }
    static pointer_type create(pointer_type const& that){ return utils::ObjectPool<Chain>::create(that); }

public:
    int last_step_amounts() const{ return chain_step_.back(); }
    int step_amounts(int const& step) const{ return chain_step_[step-1]; }

    // map will be responsible to notify Chain to push new elements to Chains.
    void add_last_step_amounts(int const& num){
        add_step_amounts(step(), num);
    }

    void add_step_amounts(int const& step, int const& num) {
        chain_step_[step-1] += num;
        step_indices_.insert(step);
    }

    void add_step_cube(int step, int x, int y) {
        step_group_[step-1].push_back( std::make_pair(x, y) );
    }

    void remove_step_cube(int step, int x, int y) {
        step_group_[step-1].remove( std::make_pair(x, y) );
    }

    std::list< std::pair<int, int> > const & get_step_group(int step) {
        return step_group_[step-1];
    }

    void step_one(){
        chain_step_.push_back(0);
        power_step_.push_back(0);
        is_step_extending_.push_back(false);
        step_group_.push_back( std::list< std::pair<int, int> >() );
    }

    int power_factor() const{
        int res = 0;
        for( size_t i = 0; i < power_step_.size(); ++i ) {
            res += power_step_[i];
        }
        return res;
    }

    void update_power_factor();
    void update_power_factor_step(int const& step);

    int step_score(int const& step) const{
        return attack_of_step(step) * 50;
    }

    int step() const{
        return chain_step_.size();
    }

    int attack_of_current_step() const {
        return power_step_.back();
    }

    int attack_of_step(int step) const {
        return power_step_[step-1];
    }

    std::set<int> const& step_indices() const {
        return step_indices_;
    }

    void set_extending(int step, bool flag) {
        is_step_extending_[step-1] = flag;
    }

    bool is_step_extending(int step) const {
        return is_step_extending_[step-1];
    }

    void clear_indices() {
        step_indices_.clear();
    }

    void debugging_print();

    Chain() {}

    Chain(pointer_type const& that):
        chain_step_(that->chain_step_),
        power_step_(that->power_step_),
        step_indices_(that->step_indices_),
        is_step_extending_(that->is_step_extending_),
        step_group_(that->step_group_)
    {}

private:
    std::vector<int> chain_step_;
    std::vector<int> power_step_;
    std::set<int>    step_indices_;
    std::vector<bool> is_step_extending_;
    std::vector< std::list< std::pair<int, int> > > step_group_;
};

typedef Chain::pointer_type pChain;
typedef Chain::wpointer_type wpChain;

}} // end of namespace

<% end %>
