
<% header_guard do %>

#include "all_fwd.hpp"

#include "data/MapSetting.hpp"
#include "data/Color.hpp"
#include "utils/vector_2d.hpp"
#include "model/SimpleMap.hpp"

#include <boost/tr1/tuple.hpp>
#include <boost/tr1/functional.hpp>
#include <map>
#include <set>
#include <list>
#include <vector>

namespace psc{
namespace model{

class Map;

template<class T>
class OneFadingT;
typedef std::tr1::shared_ptr< OneFadingT<Map> > pOneFadingOrig;

class Map : public SimpleMap
{
public:
    typedef pMap pointer_type;
    typedef pCube                        cube_type;
    typedef utils::vector_2d<pCube> container_type;
    typedef utils::vector_2d<int>   color_map_type;
    typedef std::set<pCube>         cube_list_type;
    typedef std::list<pChain>      chain_list_type;
    typedef std::vector<pCube>   preview_list_type;

public:
    static pointer_type create(presenter::wpMap owner, data::pMapSetting setting){
        // map doesn't need a pool
        return pointer_type(new Map(owner, setting))->init();
    }

public:
    Map(presenter::wpMap owner, data::pMapSetting setting):
        SimpleMap(setting), owner_(owner), cubes_(0, 0), now_t_(0), last_t_(0),
        cubes_cleared_(), cubes_matched_(), total_cubes_cleared_(0), match_counter_(0),
        highest_chain_(0), highest_color_count_(0), highest_amount_chain_step_(0),
        one_fadings_per_cycle_(0), dropping_creatable_(false), garbage_dumpable_(false),
        column_full_num_(0)
    {}
    Map& init_cubes();
    Map& init_cubes(color_map_type const&);
    ~Map();

    Map& cycle();

    // used by Dying or OneFading
    void attach_chain_bottom_up_from(int, int, pChain);
    void mark_chain_step_for_new_step(pChain, int);

    // begin used by Dropping::cycle, Waiting::cycle
    state::pState next_state(pCube);
    // end

    // only used by Game::make_garbage
    void push_garbage(int amounts);
    // end

    // for Cube#lose_chain
    bool cube_can_lose_chain(cpCube) const;

    // for Cube#drop_a_block
    Map& update_cube_position(pCube cube, int old_x, int old_y);

    // for notifying the ending effect to cubes.
    Map& ending_effect();

    color_map_type color_map() const;

    void reset_record();
    int  garbage_count() const;
    int  grounded_cube_count() const;
    int  column_full_num() const;
    int  match_count() const;
    int  highest_chain() const;
    int  highest_color_count() const;
    int  highest_amount_chain_step() const;
    int const* cubes_cleared_data() const;
    int const* cubes_matched_data() const;
    bool all_empty() const;
    bool all_waiting() const;
    int  id() const;

    // used by Cube#drop_a_frame or sink_a_frame
    double get_sink_speed() const;

    // add intrusive methods for character special ability.
    // SimpleMap probably won't need to do this, so I added them at Map level
    void set_garbage_amount(int const& n);
    void foreach(std::tr1::function<void(pCube&, int, int)> f);
    void for_row(int r, std::tr1::function<void(model::pCube&, int, int)> f);
    void apply_func_at(int x, int y, std::tr1::function<void(model::pCube&, int, int)> f);
    void kill_cube_at(int x, int y);
    void new_cube_at(int x, int y, int color_id);
    void purge_all();
    void cubes_cleared_add(int const& id);                  //called from model::Cube only.
    void cubes_matched_add(int const& num, int const& id);  //called from model::Cube only.
    void restore_neighbor(int x, int y, int dying_mode = -1);//called from model::Cube only when go_dying() is called.

    bool exist(int x, int y) const;
    bool below_is_dropping(int x, int y) const;

    std::vector< std::pair<int, int> > count_colors() const;
    std::vector< data::pCube > clone_linear_data() const;

    pSimpleMap dump_data() const;

private:
    Map& insert_cube(pCube);
    Map& insert_garbage(pCube);
    Map& insert_preview(pCube);
    void cycle_cubes();
    void check_one_fadings();
    void cycle_a_cube(pCube, int x, int y);
    int  encode_dying_metadata(cpCube c);
    void check_a_fade(pCube, int x, int y, pChain existing_chain);
    void cycle_creation();
    void cycle_creation_garbage();
    pCube insert_new_garbage_from_bag(int x, int y);
    void cycle_warning();
    void fill_preview_queue();
    int fill_preview_create_color(std::vector<int>&);
    void fill_color_bag();

    pOneFadingOrig make_OneFading(pCube);
    pCube cube_at(int x, int y) { return cubes_[x][y]; }

    bool is_below_empty(cpCube) const;
    void update_chains();
    void inc_warning(int&);
    void dec_warning(int&);
    presenter::pMap owner() const{ return owner_.lock(); }
    pMap self()             const{ return self_.lock(); }

private:
    pointer_type init();

private:
    presenter::wpMap  owner_; // should be weak_ptr
    wpMap             self_;
    container_type    cubes_;

    // Now map has to keep track of logical state with regard to precise timing
    time_t now_t_, last_t_;
    int cubes_cleared_[data::COLOR_MAX], cubes_matched_[data::COLOR_MAX], total_cubes_cleared_;
    int match_counter_;
    int highest_chain_;
    int highest_color_count_;
    int highest_amount_chain_step_;
    int one_fadings_per_cycle_;
    bool dropping_creatable_, garbage_dumpable_;
    int column_full_num_;
    std::tr1::shared_ptr<int> alarm_sound_, animate_alert_bar_; //alarming dummy
    std::tr1::shared_ptr<int> warning_handle_; //warning value's timer handle
    preview_list_type cubes_preview_;
    std::vector<int> color_bag_;

    std::map< std::pair<wpChain, int>, std::vector< std::tr1::tuple<int, int, int> > > dying_cubes_position_;
    std::map< std::pair<wpChain, int>, int > successfully_died_cube_count_;

    typedef std::tr1::shared_ptr<int> pTimerDummy;
    std::map< std::pair<wpChain, int>, pTimerDummy > chain_timer_handles_;

    friend class OneFadingT<Map>;
};

}} // end of namespace

<% end %>
