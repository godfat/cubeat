
<% header_guard do %>

#include "model/Chain.hpp"
#include "model/Cube.hpp"
#include "model/Map.hpp"
#include "utils/ObjectPool.hpp"

#include <boost/tr1/memory.hpp>

<%= debug_include %>

namespace psc{ namespace model{

template<class MapType>
class OneFadingT{
    typedef typename MapType::cube_list_type cube_list_type;

public:
    typedef std::tr1::shared_ptr<OneFadingT> pointer_type;
    static pointer_type create(cube_list_type const& list, bool const& extending = false){
        return utils::ObjectPool<OneFadingT>::create(list, extending);
    }
public:
    // begin only used by Map::next_state / next_step
    <% debug_hook 'OneFadingT' do %>(cube_list_type const& list, bool const& extending)
        : list_(list), extending_(extending), extending_at_step_(0) {<%end%>}
    typename cube_list_type::size_type size() const{ return list_.size(); }
    typename cube_list_type::iterator begin() const{ return list_.begin(); }
    typename cube_list_type::iterator end()   const{ return list_.end(); }
    pChain chain() const{ return chain_.lock(); }
    wpChain wchain() const{ return chain_; }

    void <% debug_hook 'fade' do %>(MapType& map,
                                    pChain existing_chain = pChain() ){
<% end %>
        int extending_amount = 0;
        pChain chain = get_the_chain(map, existing_chain);

        chain_ = chain; // Associate this particular OneFading with its chain.

        // I have no good way around this. If this is an extending OneFading,
        // we need to know what step in a chain it is currently extending, so have to search through it first.
        if( extending_ ) {
            for(typename cube_list_type::iterator i=list_.begin(), iend=list_.end();
                i!=iend; ++i)
            {
                // 2014.6 We have to assure that we pick the highest dying_step in all these already dying cubes we extend from
                if( (**i).is_dying() && (**i).dying_chain_step() > extending_at_step_ ) {
                    extending_at_step_ = (**i).dying_chain_step();
                }
            }
        }

        for(typename cube_list_type::iterator i=list_.begin(), iend=list_.end();
            i!=iend; ++i)
        {
            // calculate how many are "dying" or "not dying" in the traveled.
            // Since we changed the rule to allow extending already happening "OneFading"s in 2013,
            // we'll need this number to know exactly how many cubes we are extending.

            // 2014.6 since it's possible to "merge" chains in this way, have to check this possiblilty as well.
            //        other chains will be eroded after the merge.
            if( (**i).is_waiting() ) {
                extending_amount += 1;
            }
            else if( ( (**i).is_dying() && (**i).chain() != chain ) ) {
                extending_amount += 1;

                // actually "take away" cubes from other chains
                (**i).chain()->add_step_amounts( (**i).dying_chain_step(), -1 );
            }

            (**i).chain(chain);
            (**i).go_dying( extending_at_step_ != 0 ? extending_at_step_ : chain->step());

            //map.attach_chain_bottom_up_from((**i).x(), (**i).y() + 1, chain);
            //note: Moved this line to Dying to be more reasonable chaining situation.
            //      In SimpleMap this is invoked in cycle_a_cube
        }

        if( extending_ ) {
            extend_step(chain, extending_at_step_, extending_amount);
        } else {
            update_step(chain);
        }
    }
    // end

private:
    pChain get_the_chain(MapType& map, pChain existing_chain){
        pChain chain = Chain::create(map.ms()->chain_amounts());

        //this for loop will get the first Chain it finds in this column or row
        for(typename cube_list_type::iterator i=list_.begin(), iend=list_.end();
            i != iend; ++i)
        {
            if( (**i).chain() && (**i).chain()->step() > chain->step() ) {
                chain = (**i).chain();
                // 2014.06: compare for the highest chain
            }
        }

        if( chain->step() == 0 ) {
            if( existing_chain ) {
                chain = existing_chain;
            } else {
                //if we can't find any useful Chain here, we'll create one
                chain->step_one();
                map.push_chain( chain );
            }
        }
        return chain;
    }

    void update_step(pChain chain) {
        chain->add_last_step_amounts( list_.size() );
    }

    void extend_step(pChain chain, int step, int amount) {
        chain->add_step_amounts( step, amount );
    }

private:
    cube_list_type list_;
    wpChain chain_; // just association, don't hold it.
    bool extending_;
    int extending_at_step_;
};

}} // end of namespace

<% end %>
