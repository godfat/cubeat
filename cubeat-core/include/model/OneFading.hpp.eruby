
<% header_guard do %>

#include "model/Chain.hpp"
#include "model/Cube.hpp"
#include "model/Map.hpp"
#include "utils/ObjectPool.hpp"

#include <boost/tr1/memory.hpp>

<%= debug_include %>

namespace psc{ namespace model{

template<class MapType>
class OneFadingT{
    typedef typename MapType::cube_list_type cube_list_type;

public:
    typedef std::tr1::shared_ptr<OneFadingT> pointer_type;
    static pointer_type create(cube_list_type const& list, bool const& extending = false){
        return utils::ObjectPool<OneFadingT>::create(list, extending);
    }
public:
    // begin only used by Map::next_state / next_step
    <% debug_hook 'OneFadingT' do %>(cube_list_type const& list, bool const& extending)
        : list_(list), extending_(extending) {<%end%>}
    typename cube_list_type::size_type size() const{ return list_.size(); }
    typename cube_list_type::iterator begin() const{ return list_.begin(); }
    typename cube_list_type::iterator end()   const{ return list_.end(); }
    pChain chain() const{ return chain_.lock(); }
    wpChain wchain() const{ return chain_; }

    void <% debug_hook 'fade' do %>(MapType& map,
                                    typename MapType::cube_type that_would_be_killed_by_map,
                                    pChain existing_chain = pChain() ){
<% end %>
        int extending_amount = 0;
        pChain chain = existing_chain ? existing_chain : get_the_chain(map);
        chain_ = chain; // Associate this particular OneFading with its chain.

        for(typename cube_list_type::iterator i=list_.begin(), iend=list_.end();
            i!=iend; ++i)
        {
            // calculate how many are "dying" or "not dying" in the traveled.
            // Since we changed the rule to allow extending already happening "OneFading"s in 2013,
            // we'll need this number to know exactly how many cubes we are extending.
            if( (**i).is_waiting() )
                extending_amount += 1;

            (**i).chain(chain);
            if( *i != that_would_be_killed_by_map ){
                (**i).go_dying(); /// ** do something here so cubes extending chain doesn't "die" again? *** ///
                                  /// ** also remember "that_would_be_killed_by_map" *** ///
            }

            //map.attach_chain_bottom_up_from((**i).x(), (**i).y() + 1, chain);
            //note: Moved this line to Dying to be more reasonable chaining situation.
            //      In SimpleMap this is invoked in cycle_a_cube
        }

        if( extending_ ) {
            chain->revert_once();
            extend_last_step(chain, extending_amount);
        } else {
            update_step(chain);
        }
    }
    // end

private:
    pChain get_the_chain(MapType& map){
        pChain chain;

        //this for loop will get the first Chain it finds in this column or row
        for(typename cube_list_type::iterator i=list_.begin(), iend=list_.end();
            i != iend; ++i)
        {
            if( (**i).chain() ) {
                chain = (**i).chain();
                break;
            }
        }

        //if we can't find any useful Chain here, we'll create one
        if( !chain ) {
            chain = Chain::create();
            chain->step_one();
            map.push_chain( chain );
        }

        return chain;
    }

    void update_step(pChain chain) {
        chain->add_last_step_amounts( list_.size() );
    }

    void extend_last_step(pChain chain, int amount) {
        chain->add_last_step_amounts( amount );
    }

private:
    cube_list_type list_;
    wpChain chain_; // just association, don't hold it.
    bool extending_;
};

}} // end of namespace

<% end %>
