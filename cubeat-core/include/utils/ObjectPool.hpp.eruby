<% header_guard do %>

// Note: By the usage of this, we actually stucked with boost's implementation.
#include <boost/smart_ptr/make_shared.hpp>

// For thread-safe pool
#include <boost/thread/mutex.hpp>

// For backup frame window implemented with std::deque
#include <deque>

// Note: we are using our own implementation of boost.pool, in a sense,
//       so don't make the include path fool you. changed to utils.pool.
//       However, for convenience of porting, the namespace in the file remained boost::.
#include "utils/pool/object_pool.hpp"
#include "utils/pool/singleton_pool.hpp"
#include "utils/pool/pool_alloc.hpp"

#define LOKI_CLASS_LEVEL_THREADING
#include <loki/Singleton.h>

namespace psc{ namespace utils{

template <typename T, typename UserAllocator = boost::default_user_allocator_new_delete>
class object_pool_mt {
public:
    typedef typename boost::object_pool<T, UserAllocator>::element_type element_type;

    inline void destroy_mt(element_type* const chunk){
        chunk->~T();
        free_mt(chunk);
    }

    inline bool is_from(element_type* const chunk) const {
        return pool_.is_from(chunk);
    }

    element_type * construct(){
      element_type * const ret = malloc_mt();
      if (ret == 0)
        return ret;
      try { new (ret) element_type(); }
      catch (...) { free_mt(ret); throw; }
      return ret;
    }

<% for_template_parameters_within(1..5, []){ |args_list| %>
    template <%= template_parameters args_list %>
    element_type * construct(<%= forward_parameters args_list %>){
      element_type * const ret = malloc_mt();
      if (ret == 0)
        return ret;
      try { new (ret) element_type(<%= arguments args_list %>); }
      catch (...) { free_mt(ret); throw; }
      return ret;
    }
<% } %>

private:
    inline element_type* malloc_mt(){
        boost::mutex::scoped_lock lock(mutex_);
        return pool_.malloc();
    }
    inline void free_mt(element_type* p){
        boost::mutex::scoped_lock lock(mutex_);
        pool_.free(p);
    }
    boost::mutex mutex_;
    boost::object_pool<T, UserAllocator> pool_;
};

template <class T>
class ObjectPool{
public:
    typedef typename T::pointer_type element_type;

public:
    static element_type create(){
        return element_type(SPool::Instance().construct(), Deleter());
    }

<% for_template_parameters_within(1..5, []){ |args_list| %>
    template <%= template_parameters args_list %>
    static element_type create(<%= forward_parameters args_list %>){
        return element_type(SPool::Instance().construct(<%= arguments args_list %>), Deleter());
    }
<% } %>

    static void destroy_all(){
        Loki::DeletableSingleton<pool_type>::GracefulDelete();
    }

private:
    typedef object_pool_mt<T> pool_type;
    typedef Loki::SingletonHolder<pool_type, Loki::CreateUsingNew, Loki::DeletableSingleton> SPool;

    static void destroy(T* t){
        SPool::Instance().destroy_mt(t);
    }
    static bool is_from(T* t){
        return SPool::Instance().is_from(t);
    }

    friend class Deleter;
    class Deleter{
    public:
        typedef void result_type;
        typedef T* argument_type;

    public:
    // u.is_from(p)    bool    Returns true if p was allocated from u or may be returned as the result of a future allocation from u. Returns false if p was allocated from some other pool or may be returned as the result of a future allocation from some other pool. Otherwise, the return value is meaningless; note that this function may not be used to reliably test random pointer values.
        void operator()(argument_type p){
            if(ObjectPool<T>::is_from(p))
                ObjectPool<T>::destroy(p);
        }
    };
};


/// ******** Add some metadata information for restorable pool here ******** ///

// 2012.12 arch.jslin WTF NOTE:
//   Ok, This is very important note, just to remind myself of possible unresolve/unchecked situations.
//
//     1. Is it possible that my restorable object contains properties that SHOULD NOT be rollbacked?
//        Or easily neglected while it's really important that it be rollbacked(backup-ed) as well?
//
//     2. One very important fact is that objects in the backup memory blocks can't be manipulated in anyway,
//        EVEN THE DESTRUCTORS. So when those memory blocks drops (because of backup limit reached or whatever reasons)
//        Those destructors are not going to be invoked. This make sense in simple cases, since those
//        objects in the backup memory blocks are just "ghosts" and they should not interact with any other things.
//        But we'll see about that.
//
//     I'm pretty sure that in simple working cases there will be no resources leaks,
//     But I expect serious problem will happen IF situation 1 and situation 2 got mixed up.
//

const size_t MAX_SIZE_OF_BACKUP = 10;

template<typename T>
class ObjectPoolRestorable
{
    typedef boost::detail::sp_counted_impl_pda<T*, boost::detail::sp_ms_deleter<T> , boost::fast_pool_allocator<T> > FUCK_IT;
    typedef boost::singleton_pool<T, sizeof(FUCK_IT)> this_pool;
    typedef typename T::pointer_type element_type;

public:

    typedef typename this_pool::pool_type pool_type;

    static void backup(int frame_number) {
//        printf("\n FUCK BEFORE push_back a invalid pool_type() to backups_. (FULL LIST)\n");
//        for( typename std::deque<pool_type>::iterator it = backups_.begin(), end = backups_.end(); it != end; ++it ) {
//            it->show_debug();
//        }
        backups_.push_back( pool_type() );      // make sure the place holder (tmp pool) is destructed right away
//        printf("\n FUCK AFTER push_back a invalid pool_type() to backups_. (FULL LIST)\n");
//        for( typename std::deque<pool_type>::iterator it = backups_.begin(), end = backups_.end(); it != end; ++it ) {
//            it->show_debug();
//        }
//        printf("\n == before backup, the original underlying pool: ==\n");
//        this_pool::show_debug();
//        printf(" FUCK DEBUG backups_.size(): %d\n", backups_.size() );
        this_pool::clone_to( backups_.back() ); // So that it won't call destructor when tmp pool is out of scope.
//        printf("\n == after backup, the copied pool (FULL LIST): ==\n");
//        for( typename std::deque<pool_type>::iterator it = backups_.begin(), end = backups_.end(); it != end; ++it ) {
//            it->show_debug();
//        }
        tracked_frame_number_ = frame_number;

        // dump things larger than the backup window:
        if( backups_.size() > MAX_SIZE_OF_BACKUP ) {
//            printf("Backup window full.. popping \n");
            backups_.pop_front();
        }
//        printf("tracked_frame_number_ = %d, backup_size = %d\n", tracked_frame_number_, backups_.size());
    }

    static void restore(int frame_number) {
        int num_of_frames_to_rollback = tracked_frame_number_ - frame_number;
        // we are rolling-back to "frame_number", but of course we don't want to pop it!
        // it is the last finished state with the correct inputs, so it is part of the solid history!
//        printf("\n == pool restoring: tracked_frame_number = %d, num_of_frames_to_roll = %d\n", tracked_frame_number_, num_of_frames_to_rollback);

//        backups_.erase( (backups_.rbegin() - num_of_frames_to_rollback).base(), backups_.end() );

//      I really have no idea why using iterater range to erase won't compile.
//      The error seemed to have nothing to do with the iterators.
//        printf("  now popping mis-calcualted frame states....\n");
        for( ; num_of_frames_to_rollback > 0 ; --num_of_frames_to_rollback ) {
//            backups_.back().show_debug();
            backups_.pop_back();
        }
//        printf("the restoration source (backup pool): \n");
        pool_type & backup = backups_.back();
//        backup.show_debug();
//        printf("the restored destination (the new original): \n");
        this_pool::restore( backup );
//        this_pool::show_debug();
//        printf("\n == FUCK after RESTORE, check the backup list (FULL LIST): ==\n");
//        for( typename std::deque<pool_type>::iterator it = backups_.begin(), end = backups_.end(); it != end; ++it ) {
//            it->show_debug();
//        }
//        printf("\n");
    }

    static element_type create(){
        return boost::allocate_shared<T>(boost::fast_pool_allocator<T>());
    }

<% for_template_parameters_within(1..5, []){ |args_list| %>
    template <%= template_parameters args_list %>
    static element_type create(<%= forward_parameters args_list %>){
        return boost::allocate_shared<T>(boost::fast_pool_allocator<T>(), <%= arguments args_list %>);
    }
<% } %>

private:
    static std::deque<pool_type> backups_;
    static int tracked_frame_number_;
};

template<typename T>
std::deque<typename ObjectPoolRestorable<T>::pool_type> ObjectPoolRestorable<T>::backups_;

template<typename T>
int ObjectPoolRestorable<T>::tracked_frame_number_ = 0;

template<typename T>
size_t magical_sizeof(T const& something) {
    return sizeof(something);
}

template <class F, class G>
void assign(F& f, G g)
{
    f.assign(g, boost::fast_pool_allocator<G>());    // how do I know sizeof(G) outside of this function? (Because rollback need it)
}

void pools_backup(int frame_number);
void pools_restore(int frame_number);

}
} // end of namespace

<% end %>
