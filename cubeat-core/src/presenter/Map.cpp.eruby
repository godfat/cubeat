
#include "presenter/Cube.hpp"
#include "presenter/Map.hpp"
#include "model/Map.hpp"
#include "Player.hpp"

#include "utils/to_s.hpp"
#include "utils/Logger.hpp"

#include "EasingEquations.hpp"
#include "Accessors.hpp"
#include "audio/Sound.hpp"
#include "EventDispatcher.hpp"
#include "ctrl/TimerDispatcher.hpp"

#include "all_fwd.hpp"

<%= debug_include %>

using namespace psc;
using namespace presenter;
using psc::utils::to_s;

Map& Map::stop_dropping()
{
    map_setting()->garbage_dumpable(false).dropping_creatable(false);
    return *this;
}

Map& Map::start_dropping()
{
    map_setting()->garbage_dumpable(true).dropping_creatable(true);
    return *this;
}

int Map::sum_of_all_enemy() const {
    int sum = 0;
    BOOST_FOREACH(wpMap const& wmg, garbage_lands_)
        if( pMap mg = wmg.lock() )
            sum += mg->current_sum_of_attack();
    return sum;
}

bool Map::enemy_column_full() const {
    int full = 0, not_full = 0;
    BOOST_FOREACH(wpMap const& wmg, garbage_lands_) {
        if( pMap mg = wmg.lock() ) {
            if( mg->column_full_num() ) ++full;
            else ++not_full;
        }
    }
    return full >= not_full;
}

Map& <% debug_hook 'Map::push_view_slave' do %>(cube::pViewMaster view){
<% end %>
    view->init(map_setting());
    bind_view_event(view);

    // every existing cube should setup it also

    /// WTF NOTE: change data structure to list
//    typedef std::pair<model::wpCube, pCube> cube_pair_type; // macro workaround
//    BOOST_FOREACH(cube_pair_type cube_pair, cubes_){
//        pCube cube = cube_pair.second;
//        cube->push_view_slave( view->create(cube->model()) );
//    }

    BOOST_FOREACH(pCube& c, cubes_) {
        c->push_view_slave( view->create(c->model()) );
    }

    view_slaves_.push_back(view);
    return *this;
}

Map& <% debug_hook 'Map::set_view_master' do %>(cube::pViewMaster view){
<% end %>
    view->init(map_setting());
    bind_view_event(view);

    // every existing cube should setup it also

    /// WTF NOTE: change data structure to list
//    typedef std::pair<model::wpCube, pCube> cube_pair_type; // macro workaround
//    BOOST_FOREACH(cube_pair_type cube_pair, cubes_){
//        pCube cube = cube_pair.second;
//        cube->set_view_master( view->create(cube->model()) );
//    }

    BOOST_FOREACH(pCube& c, cubes_) {
        c->set_view_master( view->create(c->model()) );
    }

// WTF MEMO 2012.9 failed to adjust for balance
//    if( ctrl::pPlayer p = player_.lock() ) {
//        view->setup_ability_button();
//    }

    view_master_ = view;
    return *this;
}

pMap <% debug_hook 'Map::init' do %>(){
<% end %>
    pMap self = shared_from_this();
    model_ = model::Map::create(self, map_setting_);
    model_->init_cubes(); // beware! this need refer model_!

    return self;
}

pMap <% debug_hook 'Map::init' do %>(utils::vector_2d<int> const& data){
<% end %>
    pMap self = shared_from_this();
    model_ = model::Map::create(self, map_setting_);
    model_->init_cubes(data); // beware! this need refer model_!

    return self;
}

void <% debug_hook 'Map::bind_view_event' do %>(cube::pViewMaster view){
<% end %>
    using namespace std::tr1::placeholders;
    column_full_event(
        std::tr1::bind(&cube::ViewMaster::column_full, view.get(), _1)).
    column_not_full_event(
        std::tr1::bind(&cube::ViewMaster::column_not_full, view.get(), _1)).
    new_chain_event(
        std::tr1::bind(&cube::ViewMaster::new_chain, view.get(), _1)).
    new_garbage_event(
        std::tr1::bind(&cube::ViewMaster::new_garbage, view.get(), _1, _2)).
    pop_garbage_event(
        std::tr1::bind(&cube::ViewMaster::pop_garbage, view.get(), _1)).
    warning_counting_event(
        std::tr1::bind(&cube::ViewMaster::warning_counting, view.get(), _1));
    alert_bar_update_event(
        std::tr1::bind(&cube::ViewMaster::alert_bar_update, view.get(), _1));
    overheat_event(
        std::tr1::bind(&cube::ViewMaster::show_overheat, view.get(), _1));
// WTF MEMO 2012.9 failed to adjust for balance
//    ability_button_event(
//        std::tr1::bind(&cube::ViewMaster::ability_button, view.get(), _1));
}

void <% debug_hook 'Map::bind_cube_event' do %>(pCube cube){
<% end %>
    using namespace std::tr1::placeholders;
    cube->model()->    go_dying_event( std::tr1::bind( &Cube::go_dying, cube.get() ) ).
                   go_exploding_event( std::tr1::bind( &Cube::go_exploding, cube.get() ) ).
                     be_garbage_event( std::tr1::bind( &Cube::be_garbage, cube.get() ) ).
                      be_broken_event( std::tr1::bind( &Cube::be_broken, cube.get() ) ).
                        restore_event( std::tr1::bind( &Cube::restore, cube.get(), _1) ).
                            hit_event( std::tr1::bind( &Cube::hit, cube.get(), _1, _2 ) ).
                      get_chain_event( std::tr1::bind( &Cube::get_chain, cube.get() ) ).
                     lose_chain_event( std::tr1::bind( &Cube::lose_chain, cube.get() ) ).
//                   drop_a_block_event( std::tr1::bind( &Cube::drop_a_block, cube.get() ) ).
//                   sink_a_block_event( std::tr1::bind( &Cube::sink_a_block, cube.get() ) ).
                     update_pos_event( std::tr1::bind( &Cube::update_pos, cube.get() ) ).
                   approach_pos_event( std::tr1::bind( &Cube::approach_pos, cube.get() ) ).
                    garbage_fly_event( std::tr1::bind( &Cube::garbage_fly, cube.get() ) );
}

pCube <% debug_hook 'Map::make_cube' do %>(int x, int y, int color_id){
<% end %>
    pCube cube = Cube::create(shared_from_this(), x, y, color_id);
    bind_cube_event(cube);
    BOOST_FOREACH(cube::pViewMaster& view, view_slaves_){
        cube->push_view_slave( view->create(cube->model()) );
    }
    if(view_master_) cube->set_view_master( view_master_->create(cube->model()) );

    /// WTF NOTE: data structure changed to list
    // cubes_.insert(std::make_pair(cube->model(), cube));
    cubes_.push_back(cube);

    return cube;
}

pCube Map::make_garbage(int x, int y){
    pCube c = make_cube(x, y, -1);
    c->goto_garbage_orig();
    return c;
}

pCube <% debug_hook 'Map::make_cube_preview' do %>(int color_id){
<% end %>
    return make_cube(3, 11, color_id); //temp
}

size_t Map::get_player_ability_left() const {
    if( ctrl::pPlayer p = player_.lock() ) {
        return p->ability_left();
    }
    return 0;
}

Map& Map::push_player_ability() {
    if( ctrl::pPlayer p = player_.lock() ) {
        p->push_ability();
    }
    return *this;
}

//void Map::release(model::wpCube const& cube) {
//    if( cube.use_count() == 1 )
//        cubes_.erase(cube);
//    // WTF NOTE: This is very tricky! you have to make sure the cube's use_count() is 1,
//    //           Because we might have legitmately revived it during the rollback!
//}

/// WTF NOTE: Alternative using cubes_ as list structure.
void Map::release(wpCube const& cube) {
    // the parameter here doesn't use shared_ptr because when the shared_ptr gets passed around,
    // use_count() is not reliable at all.
    if( cube.use_count() == 1 ) {
        cubes_.remove(cube.lock()); // this should be unique remove because cubes_ only has unique elements.
    }
}

Map& Map::cleanup_dead_cubes() { // WTF NOTE: Only caused by networking rollback
    printf("pMap::cleanup_dead_cubes: ");

    container_type::iterator test_begin = cubes_.begin(), test_end = cubes_.end();
    printf("Start: %x\n",&*test_begin);
    printf("  End: %x\n",&*test_end);

    /// WTF NOTE UPDATE: leave a lot message output here, to debug model::Map::cubes_preview_ related bug.
    /// -- everytime it rollbacks after a new cube creation cycle, it will crash.

    for( container_type::iterator it = cubes_.begin(), end = cubes_.end(); it != end ;) {
        //if ( it->first.use_count() == 1 && !it->first.lock()->is_not_dangling() ) {
        if( (*it)->model().use_count() == 1 && !( (*it)->model()->is_not_dangling() ) ) {
            // I have to use this instead of unique(), because it.first is model::wpCube,
            // after lock(), IT WILL NOT BE UNIQUE OF COURSE YOU FUCKING IDIOT.
            //printf("%ld ", it->first.use_count());
            printf("%ld ", (*it)->model().use_count());
            container_type::iterator temp = it;
            ++temp;
            cubes_.erase(it);
            printf("\n\n");
            printf("Who dares to die here? color: %d, x: %d, y: %d\n", (*it)->model()->color_id(), //it->first.lock()->color_id(),
                                                                       (*it)->model()->x(),        //it->first.lock()->x(),
                                                                       (*it)->model()->y());       //it->first.lock()->y());
            printf("\n\n");

            /// note3:
            /// Cannot pause here. TimerDispatcher will get messed up for delay_suber_and_throw_garbage callback function corrupted.
            /// Even stop and start the timer like what I did in App doesn't work.
            /// Cause of crash currently unknown, I can't figure out why this will make that callback corrupted.

            /// note4:
            /// I am still pausing here for now. Because when there's model-invalidating rollbacks,
            /// I want to know.
            system("pause");

            it = temp;
            // And this is a rather complex erase: return the iterator to erase BEFORE advance it.
        } else {
            container_type::iterator temp = it;
            printf("%x > next %x %ld ", &*it, &*(++temp), (*it)->model().use_count());  //it->first.use_count());
            printf("(%d, %d)\n", (*it)->model()->x(), (*it)->model()->y());             //it->first.lock()->y());
            ++it;
        }
    }
    printf("end of cleanup\n");
    return *this;
}

Map& <% debug_hook 'Map::cycle' do %>(){
<% end %>
//    model()->cycle_slow();
//    model()->cycle_fast();
    model()->cycle();

    /// WTF DEBUG

    printf("\n");

    for( container_type::iterator it = cubes_.begin(), end = cubes_.end(); it != end ; ++it) {
        container_type::iterator temp = it;
        printf("%x > next %x %ld ", &*it, &*(++temp), (*it)->model().use_count()); //it->first.use_count());
        printf("(%d, %d)\n", (*it)->model()->x(), (*it)->model()->y());            //it->first.lock()->x(), it->first.lock()->y());
    }

    printf("\n");

    BOOST_FOREACH(cube::pViewMaster& view, view_slaves_){
        view->cycle(*this);
    }
    if( view_master_ ) view_master_->cycle(*this);
    return *this;
}

//Map& Map::cycle_slow(){
//    model()->cycle_slow();
//    return *this;
//}
//
//Map& Map::cycle_fast(){
//    model()->cycle_fast();
//    return *this;
//}
