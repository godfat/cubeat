
<% header_guard do %>

namespace psc{ namespace ctrl{

class Ai: public Player{
    typedef model::Map::pointer_type pMap;
public:
    Ai(Game::pointer_type game, pMap map):
        game_(game), map_(map), travel_limit_(3), best_amass_point_(3),
        best_chain_point_(3), best_chain_cubes_(3), shooted_(false),
        chaining_(false)
    {
        // NOTE: // trace
        std::cout << "Hi, I am Ai!" std::endl;
    }

    void full_process(pMap map){
        for(int h = height(map)-1; h>travel_limit_; --h){
            for(int w = width(map)-1; w>=0; --w){
                if( map->lookup(w, h)->is_dropping() && map->lookup(w, h).first_drop == false )
                {
                    shooted_ = true; break;
                }
                else
                {
                    shooted_ = false;
                }
            }
            if( shooted_ == false ){ break; }
        }
    }

private:
	//射擊目標方塊,對最佳發火點分數進行更新
	void shooting(pMap map, pCube cube){
        cube->i_am_hit(1); // ?
        best_chain_point_update(map);
	}

	//更新最佳的3個發火點
    void combo_rank_update(pMap map){
        int get_point = 0;
        std::tr1::tuple<int, pCube> best_chain_list[3];

        for(int h = height(map); h>travel_limit_; --h){
            for(int w = width(map); w>=0; --w){
                if(map->lookup(w,h) && map->lookup(w,h)->is_waiting()){
                    pMap tmp_map = map->clone();

                    del_block(tmp_map, w, h, true);
                    get_point = combo_counter(tmp_map);
                    for(int i=3; i>=0; --i){
                        if(get_point > get<0>(best_chain_list[i])){
                            for(int j=0; j<i; ++j){
                                // get<0>(best_chain_list[j]) = get<0>(best_chain_list[j+1]);
                                // get<1>(best_chain_list[j]) = get<1>(best_chain_list[j+1]);
                                best_chain_list[j] = best_chain_list[j+1];
                            }
                            get<0>(best_chain_list[i]) = get_point;
                            get<1>(best_chain_list[i]) = map->lookup(w, h);
                            break;
                        }
                    }
                }
            }
        }
        // NOTE: // trace
        for(int k=0; k<best_chain_cubes_.size(); ++k)
            std::cout << "Best combo<" << get<0>(best_chain_list[k]) << ">(" << get<1>(best_chain_list[k])->x() << "," << get<1>(best_chain_list[k])->y() << ")";

        std::transform(best_chain_list.begin(), best_chain_list.end(),
            best_chain_point_.begin(), get<0>(boost::lambda::_1) );

        std::transform(best_chain_list.begin(), best_chain_list.end(),
            best_chain_cubes_.begin(), get<1>(boost::lambda::_1) );
    }

    void best_chain_point_update(pMap map){
        for(int i=0; i<3; ++i){
            pMap tmp_map = map->clone();
            del_block(tmp_map, best_chain_cubes_[i]->x(), best_chain_cubes_[i]->y(), true);
            best_chain_point_[i] = combo_cunter(tmp_map);
        }
    }

    int count_square_Num(pMap map){
        int count = 0;
        for(int h=height(map); h>0; --h)
            for(int w=width(map)-1; w>=0; --w)
                if( map->lookup(w,h)->is_waiting() )
                    ++count;
        return count;
    }

    std::vector<int> top_checker(pMap map){
        std::vector<int> map_tops(width(map)+2);
        for(int h=height(map)-1; h>0; --h)
            for(int w=width(map)-1; w>=0; --w)
                if( map->lookup(w,h)->is_waiting() )
                    map_tops[w] = height(map) - h;

        for(int w=width(map)-1; w>=0; --w){
            map_tops[width(map)-1+1] += map_tops[w];
            if( map_tops[w] > map_tops[width(map)-1+2] )
                map_tops[width(map)-1+2] = map_tops[w];
        }

        map_tops[width(map)-1+1] = map_tops[width(map)-1+1]/width(map);

        // NOTE: // trace
        std::cout << "map_tops:";
        std::copy(map_tops.begin(), map_tops.end(), std::ostream_iterator<int>(std::cout, ", "))

        return map_tops;
    }

private:
    int width(pMap map){ return 6; }
    int height(pMap map){ return 11; }

private:
    int travel_limit_;
	pCube best_amass_cube_;
    std::vector<int> best_amass_point;
    std::vector<int> best_chain_point;
    std::vector<pCube> best_chain_cubes;

	bool shooted_;
    bool chaining_;
	pGame game_;
	pMap map_;

    pCube rtc_checker(pMap map){
        pMap tmp_map = map->clone();
        std::vector<pCube> true_failing_cubes, tmp_failing_cubes, tmp_failing_cubes2;

        for(int h=height(map)-1; h>0; --h){
            for(int w=width(map)-1; w>=0; --w){
                if( map->lookup(w, h)->is_dropping() && map->lookup(w, h).first_drop == false ){
                    true_failing_cubes.push_back(map->lookup(w, h));
                    tmp_failing_cubes.push_back(tmp_map->lookup(w, h));
                }
                if(map->lookup(w, h).use_count() == 0){
                    for(int y=h; y>0; --y){
                        if(map->lookup(w, y)->is_dropping() &&
                           map->lookup(w, h).first_drop == false)
                        {
                            break;
                        }
                    }
                }
            }
        }

        failing_dropping(tmp_map, false);
        if( contact_checker(tmp_map, 3).use_count() != 0 ){
            return pCube();
        }
        else{
            for(int h=height(map); h>0; --h){
                for(int w=width(map); w>=0; --w){
                    if(map->lookup(w, h) && map->lookup(w, h)->is_waiting()){
                        pMap tmp_map2 = tmp_map->clone();
                        tmp_failing_cubes_2.clear();
                        for(int i=0; i<tmp_failing_cubes.size(); ++i){
                            tmp_failing_cubes_2.push_back(tmp_map_2.lookup(tmp_failing_cubes[i]->x(), tmp_failing_cubes[i]->y()));
                        }
                        del_block(tmp_map_2, w, h, true);
                        std::vector<pCube> tmp_rtc_list;
						for(int j = 0; j<temp_failing_cubes_2.size(); ++j){
							temp_chain_list = contact_checker_unit(temp_map_2, temp_map_2.lookup(temp_failing_cubes_2[j]->x(),temp_failing_cubes_2[j]->y()), temp_rtc_list, 3);
						}
						if(temp_rtc_list.size() !=0){
							for(int recy=0; recy<temp_rtc_list.size(); ++recy){
								temp_rtc_list[recy].cycled = false;
							}
						}
                    }
                }
            }
        }
    }

	std::vector<pCube> too_high_travel(pMap map){
		std::vector<> map_tops = top_checker(map);// get high of each column
        std::vector<pCube> del_list(width(map)); // to save cubes that need delete
		for(int w = width(map)-1; w > 0; --w){
			//如此列高度超過平均值2
			if(map_tops[w] - map_tops[width(map)-1+1] > 2){
				// travel this column
				// NOTE: tracing
				std::cout << "column(" << w << ")too high";
				del_list[w] = column_travel(map, w);
			}
		}
		for(int j = 0; j < del_list.size(); ++j){
			if( del_list[j] ){
				return del_list;
			}
		}
		return std::vector<pCube>();
	}

    std::vector<pCube> column_travel(pMap map, int w){
		std::vector<pCube> del_list; // to save cubes that need delete
		for(int h = height(map)-1; h > 0; --h){
			if( map->lookup(w,h) && map->lookup(w,h)->is_waiting() ){
				// // trace("check(" + h + ")>>" + map.make_column(map->lookup(w,h)).size());
				// find 2-contact at this column
				if(map->make_column(map->lookup(w,h)).size() >= 1){
					// check which one is higher than the other
					// map.make_column(map->lookup(w,h))[0] always higher(<) than h
					// NOTE: tracing
					std::cout << "find 2-contact at(" << w << "," << h << ")";
					std::vector<pCube> del_list_up;
					std::vector<pCube> del_list_down;
					for(int ph = 1; h + ph < 11 && h - 1 - ph > 0 && ph < 3; ++ph){
						if(map->lookup(w,h + ph) == map->lookup(w,h) && map->lookup(w,h + ph)->is_waiting){
						    // NOTE: tracing
							std::cout << "column_travel_dw find!";
							del_list = del_list_down;
							break;
						}else{
							std::cout << "push_dw: " << w << "," << (h + ph);
							del_list_down.push_back(map->lookup(w,h + ph));
						}
						if(map->lookup(w,h - 1 - ph) == map->lookup(w,h) && map->lookup(w,h - 1 - ph)->is_waiting()){
							// // trace("column_travel_up find!");
							del_list = del_list_up;
							break;
						}else{
							// // trace("push_up: " + w + "," + (h - 1 - ph));
							del_list_up.push_back(map->lookup(w,h - 1 - ph));
						}
					}
					if(del_list.size() != 0){
						break;
					}
					--h;
				}
			}
		}
		return del_list;
	}

	//暴搜盤面,找出broken或是garbage方塊並回傳
	 std::tr1::tuple< std::vector<pCube>, std::vector<pCube> > bk_gbg_travel(pMap map){
	     //儲存broken_cubes //儲存garbage_cubes
		std::tr1::tuple< std::vector<pCube>, std::vector<pCube> > bg_cubes;
		for(int h = height(map)-1; h > 0; --h){
			for(int w = width(map)-1; w >= 0; --w){
				if(map->lookup(w,h)->is_waiting() && map->lookup(w,h)->if_broken() == true){
					// trace("push broken(" + w + "," + h +")");
					get<0>(bg_cubes).push_back(map->lookup(w,h));
				}else if(map->lookup(w,h)->is_waiting() && map->lookup(w,h).if_garbage() == true){
					// // trace("push garbage(" + w + "," + h +")");
					get<1>(bg_cubes).push_back(map->lookup(w,h));
				}
			}
		}
		if(get<0>(bg_cubes).size()!=0 || get<1>(bg_cubes).size()!=0){
			return bg_cubes;
		}else{
			return std::tr1::tuple< std::vector<pCube>, std::vector<pCube> >();
		}
	}

	//暴搜盤面找出最佳發火點並回傳
	pCube combo_travel(pMap map){
		int combo_point = 0;
        pCube best_cube;
		for(int h = height(map)-1; h > travel_limit_; --h){
			for(int w = width(map)-1; w >= 0 ; --w){
				if(map->lookup(w,h) && map->lookup(w,h)->is_waiting()){
					Map temp_map = map->clone();
					del_block(temp_map, w, h, true);
					if(combo_counter(temp_map)>combo_point){
						combo_point = combo_counter(temp_map);
						best_cube = map->lookup(w,h);
					}
				}
			}
		}
		return best_cube;
	}

	//暴搜盤面找出最佳發火點並回傳(使用combo_rank_udate)
	pCube combo_travel_ver2(pMap map){
		combo_rank_update(map);
		return best_chain_cubes[2];
	}

	//計算此盤面的兩兩相臨方塊個數 並回傳
	int amass_counter(pMap map){
		if(contact_checker(map, 3).size() == 0){
			int get_point = 0;
			get_point = contact_checker(map, 2).size();
			return get_point;
		}
		return 0;
	}

	pCube amass_travel(pMap map){
		int get_point = 0;
		pCube best_cube;
		int amass_point = amass_counter(map);
		for(int h = height(map)-1; h > travel_limit_; --h){
			for(int w = width(map)-1; w >= 0 ; --w){
				if(map->lookup(w,h) && map->lookup(w,h)->is_waiting()){
					Map temp_map = map->clone();
					del_block(temp_map, w, h, true);
					get_point = amass_counter(temp_map);
					if(get_point > amass_point){
						amass_point = get_point;
						best_cube = map->lookup(w,h);
					}
				}
			}
		}
		return best_cube;
	}

};

}} // end of namespace

class Ai{
	//深層暴搜盤面找出最佳排列點並回傳
	pCube amass_travel_deep(pMap map){
		pCube best_cube;//最佳排列點方塊
		bool in_best_cubes = false;
		int best_point = 0;
		best_point = amass_deep_formula(amass_counter(map),this.best_chain_point);
		for(var h = map.Height-1; h > this.travel_limit; --h){
			for(var w = map.Width-1; w >= 0 ; --w){
				for(var i = this.best_chain_cubes.length; i >=0; --i){
					if(w == this.best_chain_cubes[a].x && h == this.best_chain_cubes[a].y){
						in_best_cubes = true;
						break;
					}
				}
				if(map.lookup(w,h)!= null && map.lookup(w,h).state instanceof Waiting && in_best_cubes != true){
					var temp_map: Map = set_brain_map(map);//temp_map為消去被評價點(w,h)之後的map
					var temp_best_chain_cubes: Array = [null, null, null];//暫存最佳發火點,以防消去被評價點後造成最佳發火點位址變動
					for(var a = 0; a < this.best_chain_cubes.length; ++a){
						temp_best_chain_cubes[a]=temp_map.lookup(this.best_chain_cubes[a].x,this.best_chain_cubes[a].y);
					}
					del_block(temp_map, w, h, true);//消去被評價點(w,h)
					var chain_point: Array = [0,0,0];
					for(var j = this.best_chain_cubes.length; j >=0; --j){
						if(temp_best_chain_cubes[j]!=null){
							var temp_map_2: Map = set_brain_map(temp_map);
							del_block(temp_map_2,temp_best_chain_cubes[j].x,temp_best_chain_cubes[j].y,true);
							chain_point[j] = combo_counter(temp_map_2);
							delete temp_map_2;
						}
					}
					if(amass_deep_formula(amass_counter(temp_map),chain_point) > best_point){
						trace("find best amass(" + w + "," + h + ")");
						best_point = amass_deep_formula(amass_counter(temp_map),chain_point);
						best_cube = map.lookup(w,h);
					}
					delete temp_map;
				}
				in_best_cubes = false;
			}
		}
		return best_cube;
	}
	
	amass_deep_formula(int amass_point,Array chain_points): int{
		var amass_deep_point = amass_point;
		for(var i = 0; i < chain_points.size(); ++i){
			amass_deep_point += chain_points[i];
		}
		return amass_deep_point;
	}
	
	public function dropping_travel(pMap map){
		var del_arr = Dropping_checker(map);
		if(del_arr != null){
			// trace_map_rgb(map);
			for(var del_i = 0; del_i < del_arr.size(); ++del_i){
				shooting(map,del_arr[del_i]);
				// trace("del_dropping(" + del_arr[del_i].x + "," + del_arr[del_i].y + ")");
			}
		}
	}
	
	//計算此盤面的連鎖分數並回傳
	combo_counter(pMap map): int{
		Array square_count = new Array();
		int chain_count = 0;
		int get_point = 0;
		while(contact_checker(map,3) != null){
			//use Array to save contace_checker
			Array chain_arr = new Array();
			chain_arr = contact_checker(map,3);
			++chain_count;
			square_count.push(chain_arr.size());
			chain_del(map, chain_arr);
		}
		//point_formula : (del_square_in_each_chain-3)*each_chain_Num+2^(each_chain_Num-2)
		for(var i = 0; i < square_count.size(); ++i){
			get_point += (square_count[i]-3)*i+1;
			if( i == 0 ){
				get_point += (square_count[i]-3)*(i+1);
			}else{
				get_point += (square_count[i]-3)*(i+1) + Math.pow(2, i-1);
			}
		}
		return get_point;
	}
	//暴搜盤面,找出兩兩相鄰或是可連鎖消去的方塊並回傳,以contact_Num決定有幾個同色相連才要回傳
	contact_checker(pMap map, int contact_Num): Array{
		Array temp_arr = new Array();
		Array push_arr = new Array();
		for(int h = height(map)-1; h > 0; --h){
			for(int w = width(map)-1; w >= 0 ; --w){
				temp_arr = contact_checker_unit(map, map->lookup(w,h), temp_arr, contact_Num);
				
				/*if(map.make_row(map->lookup(w,h)).size() >= contact_Num-1){
					push_arr = map.make_row( map->lookup(w,h) );
					push_arr.push( map->lookup(w,h) );
					for(var push_row = 0; push_row < push_arr.size(); ++push_row){
						if(push_arr[push_row].cycled == false){
							push_arr[push_row].cycled = true;
							temp_arr.push(push_arr[push_row]);
						}
					}
				}
				if(map.make_column(map->lookup(w,h)).size() >= contact_Num-1){
					push_arr = map.make_column( map->lookup(w,h) );
					push_arr.push( map->lookup(w,h) );
					for(var push_col = 0; push_col < push_arr.size(); ++push_col){
						if(push_arr[push_col].cycled == false){
							push_arr[push_col].cycled = true;
							temp_arr.push(push_arr[push_col]);
						}
					}
				}*/
			}
		}
		for(var re_cy = 0; re_cy < temp_arr.size(); ++re_cy){
			temp_arr[re_cy].cycled = false;
		}
		if(temp_arr.size() == 0){
			return null;
		}else{
			return temp_arr;
		}
	}
	
	contact_checker_unit(pMap map, pCube cube, Array list, int contact_Num): Array{
		Array temp_list = new Array;
		if(map.make_row(cube).size() >= contact_Num-1){
			temp_list = map.make_row( cube );
			temp_list.push( cube );
			for(var push_row = 0; push_row < temp_list.size(); ++push_row){
				if(temp_list[push_row].cycled == false){
					temp_list[push_row].cycled = true;
					list.push(temp_list[push_row]);
				}
			}
		}
		if(map.make_column(cube).size() >= contact_Num-1){
			temp_list = map.make_column( cube );
			temp_list.push( cube );
			for(var push_col = 0; push_col < temp_list.size(); ++push_col){
				if(temp_list[push_col].cycled == false){
					temp_list[push_col].cycled = true;
					list.push(temp_list[push_col]);
				}
			}
		}
		return list;
	}
	
	//檢查初落下方塊是否會造成誤消去,有則return一組cube array
	Dropping_checker(pMap map): Array{
		Map temp_map = set_brain_map(map);
		Array check_arr = new Array();
		Array dropping_arr = new Array();
		Array del_arr = new Array();
		for(int h = height(map)-1; h > 0; --h){
			for(int w = width(map)-1; w >= 0 ; --w){
				if(map->lookup(w, h)->is_dropping() && map->lookup(w, h).first_drop == true){
					dropping_arr.push(map->lookup(w, h));
					check_arr.push(temp_map->lookup(w,h));
				}
			}
		}
		failing_dropping(temp_map,true);
		if(contact_checker(temp_map, 3) == null){
			delete temp_map;
			return null;
		}else{
			for(var check_i = 0; check_i < check_arr.size(); ++check_i){
				if(temp_map.make_row(check_arr[check_i]).size() >= 2){
					del_arr.push(dropping_arr[check_i]);
				}else if(temp_map.make_column(check_arr[check_i]).size() >= 2){
					del_arr.push(dropping_arr[check_i]);
				}
			}
			delete temp_map;
			return del_arr;
		}
	}
	//傳入一cube array,先消去這些cube,再將消去後造成的空格填滿
	chain_del(pMap map, Array del_arr){
		//delete del_arr
		for(var cube_Num = 0; cube_Num < del_arr.size(); ++cube_Num){
			del_block(map, del_arr[cube_Num].x, del_arr[cube_Num].y, false);
		}
		//sort map
		for(int h = height(map)-1; h > 0; --h){
			for(int w = width(map)-1; w >= 0 ; --w){
				if(map->lookup(w, h) == null){
					move_block(map, w, h, false);
				}
			}
		}
	}
	//消去map中位於(x,y)的cube,由need_move傳入之值決定是否要將消去後造成的空格填起
	del_block(pMap map, int x, int y, bool need_move){
		var del_x = x;
		var del_y = y;
		map[del_y][del_x].suicide();
		map.delData(del_x, del_y);
		if(need_move == true){
			move_block(map, del_x, del_y, false);
		}
	}
	//傳入map中之空格座標(x,y),向(x,y)上方進行搜尋,將(x,y)上方之方塊強制下移填滿空格
	move_block(pMap map, int x, int y){
		var locx = x;
		var locy = y;
		for(var target_y = locy-1;
			target_y > 0 &&
			map->lookup(locx,locy) == null;
			--target_y){
			if(map->lookup(locx,target_y) != null){
				if(map->lookup(locx,target_y)->is_waiting()){
					map.setup(locx, locy, map->lookup(locx, target_y));
					map->lookup(locx, locy).y = locy;
					//// trace("move dorpping cube(" + locx + "," + target_y + ") to (" + locx + "," + locy + ")");
					del_block(map, locx, target_y, true);
				}
			}
		}
	}
	//將落下中方塊強制落下,由first_drop決定目標是否為初落下方塊
	failing_dropping(pMap map, bool first_drop){
		for(int h = height(map)-1; h > 0; --h){
			for(int w = width(map)-1; w >= 0 ; --w){
				if(map->lookup(w,h)->is_dropping() && map->lookup(w,h).first_drop == true && first_drop == true){
					for(var move_to = h+1; move_to < height(map) && map->lookup(w,move_to) == null; ++move_to){
						map.setup(w, move_to, map->lookup(w, h));
						map->lookup(w, move_to).y = move_to;
						del_block(map, w, move_to, false);
						if(move_to+1 == height(map) || map->lookup(w,move_to+1) != null){
							map->lookup(w, move_to).state(new Waiting(map));
						}
					}
				}else if(map->lookup(w,h)->is_dropping() && map->lookup(w,h).first_drop == false && first_drop == false){
					for(var move_to = h+1; move_to < height(map) && map->lookup(w,move_to) == null; ++move_to){
						map.setup(w, move_to, map->lookup(w, h));
						map->lookup(w, move_to).y = move_to;
						del_block(map, w, move_to, false);
						if(move_to+1 == height(map) || map->lookup(w,move_to+1) != null){
							map->lookup(w, move_to).state(new Waiting(map));
						}
					}
				}
			}
		}
	}
};

<% end %>
