
<% header_guard do %>

#include "utils/math.hpp"
#include "utils/ObjectPool.hpp"
#include <tr1/memory>
#include <vector>

// #include "Sound.hpp"

namespace psc{ namespace model{

class Chain{
public:
    typedef std::tr1::shared_ptr<Chain> pointer_type;
    static pChain create(){ return utils::ObjectPool<Chain>::create(); }

public:
    int last_step_amounts() const{ return chain_step_.back(); }

    void add_last_step_amounts(int num){
		chain_step_.back() += num;
		// always add onto the rear element
		// map will be responsible to notify Chain to push new elements to Chains.
	}

	void step_one(){
		chain_step_.push_back(0);
        // Sound::i().combo( chain_step_.size() );
	}

    int power_factor() const{
		int result = 0;
		for(int i=0, iend=chain_step_.size(); i!=iend; ++i){
			if( chain_step_[i] < 3 ) break;
			if( i == 0 )
				result += (chain_step_[i] - 2)*(i+1);
			else
				result += (chain_step_[i] - 2)*(i+1) + utils::power2(i-1);
		}
		return result;
	}

    // this returns the score fragment made by the last combo
	int score_step() const{
		return chain_step_.back() * 20 * chain_step_.size();
	}

	int step() const{
	    return chain_step_.size();
	}

private:
    std::vector<int> chain_step_;
};

}} // end of namespace

<% end %>
