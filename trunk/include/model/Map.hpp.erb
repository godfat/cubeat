
// in all_fwd.hpp

namespace psc{
    
namespace presenter{
    class Map;
    typedef shared_ptr<Map> pMap;
    typedef weak_ptr<Map> wpMap;
    ...
    ...
    ...
}

namespace model{
    class Map;
    typedef shared_ptr<Map> pMap;
    typedef weak_ptr<Map> wpMap;
    ...
    ...
    ...
}

...
...
...

}



<%= header_guard %>

#include <boost/multi_array.hpp>
#include <boost/lambda/lambda.hpp>
#include "presenter/Map.hpp"
#include "model/Cube.hpp"
#include "data/MapSetting.hpp"
#include "utils/ChainChecker.hpp"

namespace psc{ namespace model{

class Map{
public:
    typedef std::tr1::shared_ptr<Map> pointer_type;
    typedef multi_array<pCube, 2> container_type;

public:
    static pointer_type create(pMapSetting setting){
        // map doesn't need a pool
        return pointer_type(new Map(setting));
    }
    Map(pMapSetting setting): setting_(setting),
     cubes_(extents[setting.width][setting.height])
    {
        init_cubes();
    }
    pMap& cycle(){
        n_of_newcomers_ = 0;
        for_each(cubes, bind(Map::do_cycle, this));
        return *this;
    }
    pMapSetting& ms() const{ return *setting_; }
private:
    void do_cycle(pCube c, int i){
        if(c){
            if( !c->has_grounded()  ) ++n_of_newcomers_;
            if(  c->cycle_and_die() ) cubes_[i] = NULL;
        }
    }
private:
    Map& init_cubes(){
        using boost::lambda::_1; // this would be used in for_each for element
        using boost::lambda::_2; // this would be used in for_each for index
		vector_2d square_colors(ms().width(), ms().starting_line());

        int const one_color_amounts = std::ceil(
            static_cast<double>(ms().width())*ms().starting_line()/ms().color_amounts()
        );
        for_each(square_colors, _1 = _2/one_color_amounts);

        ChainChecker::until_no_chained_cubes(square_colors, ms().chain_amounts());

        for(int i=0, iend=square_colors.num_elements(); i!=iend; ++i)
        {
            // insert(Cube::create(this, i%ms().width(), ms().height()-1-i/ms().width(), squares_colors[i]));
            insert(presenter_->make_cube(i%ms().width(), // x
                                         ms().height()-1-i/ms().width()), // y
                                         squares_colors[i]);
        }
        return *this;
    }
    Map& insert(pCube cube){
        cubes_[x][y] = cube;
    }

private:
    presenter::wpMap presenter_; // should be weak_ptr;
    pMapSetting setting_;
    container_type cubes_;
};

typedef Map::pointer_type pMap;

}} // end of namespace

#endif
