
<% header_guard do %>

#include "model/Cube.hpp"

#include "all_fwd.hpp"

#include "data/MapSetting.hpp"
#include "utils/vector_2d.hpp"

#include <tr1/functional>
#include <set>
#include <list>
#include <vector>

#include <ctime>

namespace psc{ namespace model{

class Map{
public:
    typedef pMap pointer_type;
    typedef utils::vector_2d<pCube> container_type;
    typedef std::set<pCube> cube_list_type;
    typedef std::list<pChain> chain_list_type;
    typedef std::vector<pCube> preview_list_type;

    typedef utils::vector_2d<int> color_map_type;

public:
    static pointer_type create(presenter::wpMap owner, data::pMapSetting setting){
        // map doesn't need a pool
        return pointer_type(new Map(owner, setting));
    }

public:
    Map(presenter::wpMap owner, data::pMapSetting setting):
        owner_(owner), setting_(setting),
        cubes_(setting->width(), setting->height()),
        garbage_left_(0), score_(0), lose_warning_step_(0),
        counting_num_(0), warning_check_step_(0)
    {}
    Map& init_cubes();
    <% debug_hook '~Map' do %>(){<%end%>}

    Map& cycle_slow(){
        garbage_dumpable_ = ms()->garbage_dumpable();
        dropping_creatable_ = ms()->dropping_creatable();

        refresh_cubes(); // make cube to cycle
    	update_chains();
        cycle_cubes();

		cycle_warning();
        return *this;
    }
    Map& cycle_fast(){
        if( garbage_dumpable_ && garbage_left_ > 0 )
            cycle_creation_garbage();
    	else if( dropping_creatable_ )
    	    cycle_creation();
        return *this;
    }

    data::pMapSetting const& ms() const{ return setting_; }

    // begin used by Dropping::cycle, Waiting::cycle
    state::pState next_state(pCube);
    // end

    // begin only used by OneFading::fade
    void cubes_belong_to_the_chain_from_bottom_to_top(pCube, pChain);
    // end

    // begin only used by OneFading::get_the_chain
    //   which is used by OneFading::fade
    void push_chain(pChain chain){ chains_.push_back(chain); }
    // end

    // only used by Game::make_garbage
    void <% debug_hook 'push_garbage' do %>(int amounts){ <%end%> garbage_left_ += amounts; }
    // end

    // for Cube#lose_chain
    bool cube_can_lose_chain(cpCube) const;

    // container_type const& cubes() const{ return cubes_; }
    color_map_type color_map() const;

private:
    Map& insert_cube(pCube);
    Map& insert_garbage(pCube);
    Map& insert_preview(pCube);
    void refresh_cubes();
    void cycle_cubes();
    void cycle_a_cube(pCube, int x, int y);
    void cycle_creation();
    void cycle_creation_garbage();
    void cycle_warning();
    void fill_preview_queue();
    int fill_preview_create_color(std::vector<int>&);

    void make_row(pCube that, cube_list_type&, cube_list_type&);
    void make_column(pCube that, cube_list_type&, cube_list_type&);
    void make_clist(cube_list_type&, cube_list_type&, cube_list_type&);
    pOneFading make_OneFading(pCube);
    bool is_below_empty(cpCube) const;
    void update_chains();
    bool check_column_full() const;
    presenter::pMap owner() const{ return owner_.lock(); }

private:
    presenter::wpMap owner_; // should be weak_ptr;
    data::pMapSetting setting_;
    container_type cubes_;
    int garbage_left_, score_;//, dropping_cubes_, grounded_cubes_;
    bool dropping_creatable_, garbage_dumpable_;
    // someday make it to be std::list
    chain_list_type chains_;
    preview_list_type cubes_preview_;
    std::time_t lose_warning_step_;
    int counting_num_, warning_check_step_;
};

}} // end of namespace

<% end %>
