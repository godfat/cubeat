
<% header_guard do %>

#include "view/Sprite.hpp"
#include "presenter/cube/ViewMaster.hpp"
#include "data/ViewSpriteSetting.hpp"
#include "data/Color.hpp"
#include "utils/Random.hpp"
#include "utils/to_s.hpp"

#include "Accessors.hpp"
#include "EasingEquations.hpp"
#include "Input.hpp"
#include "Player.hpp"
#include "Sound.hpp"

#include "all_fwd.hpp"

#include <boost/foreach.hpp>

#include <tr1/functional>

<%= debug_include %>

namespace psc{ namespace presenter{ namespace cube{

// stupid binding would be a must,
// without it, ViewSprite, Sprite, etc. would be destroyed by GC!
// then enable_shared_from_this would be used.
class ViewSprite: public ViewBase, public std::tr1::enable_shared_from_this<ViewSprite>{
public:
    static ViewBase::pointer_type create(model::pCube cube, view::pObject view_orig_,
        data::pMapSetting map_setting, data::pViewSpriteSetting setting, ctrl::wpPlayer const& player)
    {
        return utils::ObjectPool<ViewSprite>::create(cube, view_orig_, map_setting, setting, player);
    }
public:
    ViewSprite(model::pCube c, view::pObject orig,
        data::pMapSetting ms, data::pViewSpriteSetting s, ctrl::wpPlayer p):
        ViewBase(c), view_orig_(orig), cube_(c), map_setting_(ms), setting_(s), player_(p)
    {
        body_ = view::Sprite::create("cubes/cube1", view_orig_.lock(),
                                     s->cube_size(), s->cube_size(), true);

        body_->set<accessor::Pos2D>(pos_vec2());

        restore(c->data()->color_id());
    }

    virtual void <% debug_hook 'drop_a_block' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_dropping_duration());
    }

    virtual void <% debug_hook 'sink_a_block' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_sinking_duration());
    }

    //note: this is temporary speed function
    float speed(ctrl::Button const* btn){
         return btn->state() == ctrl::BTN_DOWN ? 400.f : map_setting()->speed();
    }

    virtual void <% debug_hook 'drop_a_block_with_callback' do %>(callback_type callback){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_dropping_duration(), 0,
            std::tr1::bind(&ViewSprite::check_if_need_callback, shared_from_this(), callback));
    }

    virtual void <% debug_hook 'sink_a_block_with_callback' do %>(callback_type callback){ <% end %>
        if( ctrl::pPlayer p = player_.lock() ) {
            body_->tween( data::AnimatorParam<easing::Linear, accessor::Pos2D>().end(pos_vec2())
                  .cb(callback).speedfunc(std::tr1::bind(&ViewSprite::speed, this, &p->input()->haste())) );
        } else {
            body_->tween<easing::Linear, accessor::Pos2D>(
                pos_vec2(), map_setting()->cube_sinking_duration(), 0,
                std::tr1::bind(&ViewSprite::check_if_need_callback, shared_from_this(), callback));
        }
    }

    virtual void <% debug_hook 'go_dying' do %>(){ <% end %>
        unsigned int duration = map_setting()->cube_dying_duration();
        body_->tween<easing::Linear, accessor::GradientEmissive>(128, duration);
        body_->tween<easing::Linear, accessor::Alpha>(0, duration);
        body_->tween<easing::Linear, accessor::Rotation>(vec3(0,0,180), duration);
        body_->tween<easing::IQuad, accessor::Scale>(vec3(0,0,0), duration);
    }

    virtual void <% debug_hook 'go_exploding' do %>(){ <% end %>
        body_->clearAllTween();
        body_->setPickable(false);
        // stupid binding would be a must,
        // without it, ViewSprite, Sprite, etc. would be destroyed by GC!
        body_->setDepth(-40); //so it is not blocked in view;
        body_->tween<easing::OQuad, accessor::Scale>(vec3(1.3,1.3,1.3), 300);
        body_->tween<easing::Linear, accessor::Alpha>(0, 300);
        body_->tween<easing::Linear, accessor::GradientEmissive>(255, 300,
            0, std::tr1::bind(&ViewSprite::just_for_hold_shared_ptr, shared_from_this()) );
    }

    virtual void <% debug_hook 'be_broken' do %>(){ <% end %>
        body_->setTexture("cubes/cube" + utils::to_s(utils::random(4)+1));
        body_->set<accessor::GradientDiffuse>( 255 );
        body_->tween<easing::OBack, accessor::Scale>(vec3(.7,.7,.7), vec3(1,1,1), 300u);
        shot_event(&model::Cube::restore, &model::Cube::go_exploding);
        Sound::i().play("1/d/ShotA@11.wav");
    }

    virtual void <% debug_hook 'restore' do %>(int color_id){ <% end %>
        if( color_id == -1 ) return;
        body_->setTexture("cubes/cube" + utils::to_s(utils::random(4)+1));
        data::Color col = data::Color::from_id(color_id);
        col.offset();
        body_->set<accessor::ColorDiffuse>( 0xff000000 | col.rgb() );
        body_->tween<easing::OBack, accessor::Scale>(vec3(.7,.7,.7), vec3(1,1,1), 300u);
        shot_event(&model::Cube::go_exploding, &model::Cube::be_broken);
    }

    virtual void <% debug_hook 'be_garbage' do %>(){ <% end %>
        body_->setTexture("cubes/cube" + utils::to_s(utils::random(4)+1));
        body_->set<accessor::GradientDiffuse>( 100 );
        shot_event(&model::Cube::go_exploding);
    }

    virtual void <% debug_hook 'hit' do %>(int /*dmg*/, int hp){ <% end %>
        int alpha = body_->get<accessor::Alpha>();
        body_->tween<easing::Linear, accessor::Alpha>(alpha/2 + 30, 300);
        body_->tween<easing::OBack, accessor::Scale>(vec3(.7,.7,.7), vec3(1,1,1), 300u);
        if( cube_.lock()->is_garbage() )
            Sound::i().play("1/c/GlassF@11.wav");
        else Sound::i().play("1/b/HitB@11.wav");
    }

    virtual void <% debug_hook 'get_chain' do %>(){ <% end %>
        if( !cube_.lock()->is_garbage() && !cube_.lock()->is_broken() )
        body_->tween<easing::SineCirc, accessor::GradientEmissive>(100, 500u, -1);
    }

    virtual void <% debug_hook 'lose_chain' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::GradientEmissive>(0, 100u);
    }

private:
    template <class MemFn>
    ViewSprite& shot_event( MemFn ally_cb, MemFn enemy_cb ) {
        using namespace std::tr1::placeholders;
        if( ctrl::pPlayer p = player_.lock() ) {
            p->subscribe_shot_event( body_,
                std::tr1::bind( &ViewSprite::check_cube_and_do, std::tr1::mem_fn(ally_cb), cube_, _1),
                std::tr1::bind( &ViewSprite::check_cube_and_do, std::tr1::mem_fn(enemy_cb), cube_, _1)
            );
        }
        return *this;
    }
    template <class MemFn>
    ViewSprite& shot_event( MemFn ally_cb ) {
        using namespace std::tr1::placeholders;
        if( ctrl::pPlayer p = player_.lock() ) {
            p->subscribe_shot_event( body_,
                std::tr1::bind( &ViewSprite::check_cube_and_do, std::tr1::mem_fn(ally_cb), cube_, _1),
                0);
        }
        return *this;
    }
    data::pMapSetting map_setting() const{ return map_setting_.lock(); }
    data::pViewSpriteSetting setting() const{ return setting_.lock(); }
    vec2 pos_vec2() const{
        data::pViewSpriteSetting s = setting();
        data::pCube d = data();
        return vec2( ( d->x()*s->cube_size() + s->cube_size()/2 ),
                     ( d->y()*s->cube_size() + s->cube_size()/2 )*-1 );
                                            // NOTE: reversed y
    }
    static void check_cube_and_do(std::tr1::function<void(model::pCube, int)> method,
        model::wpCube c, int dmg)
    {
        if(model::pCube cube = c.lock()) method(cube, dmg);
    }
    void <% debug_hook 'check_if_need_callback' do %>(callback_type callback){ <% end %>
        if(model::pCube c = cube_.lock()) callback();
    }
    void just_for_hold_shared_ptr(){}

private:
    view::pSprite  body_;
    view::wpObject view_orig_;
    model::wpCube  cube_;
    data::wpMapSetting map_setting_;
    data::wpViewSpriteSetting setting_;
    ctrl::wpPlayer player_;
};

class ViewSpriteMaster: public ViewMaster{
public:
    static ViewMaster::pointer_type create(view::pScene scene, data::pViewSpriteSetting setting, ctrl::wpPlayer const& player = ctrl::wpPlayer())
    {
        return ViewMaster::pointer_type(new ViewSpriteMaster(scene, setting, player));
    }
    static ViewMaster::pointer_type create(view::pScene scene)
    {
        return create(scene, data::ViewSpriteSetting::create());
    }
public:
    // no covariant return type
    virtual ViewBase::pointer_type create(model::pCube cube) const{
        return ViewSprite::create(cube, view_orig_, map_setting(), setting_, player_);
    }
    virtual vec2 pos_vec2(int const& x, int const& y) const{
        return vec2( setting_->x_offset() + x*setting_->cube_size() + setting_->cube_size()/2,
                     setting_->y_offset() +(y*setting_->cube_size() + setting_->cube_size()/2)*-1 );
                     //note: y reversed
    }
private:
    ViewSpriteMaster(view::pScene scene, data::pViewSpriteSetting setting, ctrl::wpPlayer const& player):
        ViewMaster(scene), setting_(setting), player_(player)
    {   //temporary
        view_orig_ = view::Object::create( scene );
        view_orig_->set<accessor::Pos2D>( vec2(setting->x_offset(), setting->y_offset()) );
    }
private:
    data::pViewSpriteSetting setting_;
    ctrl::wpPlayer player_;
};

}}} // end of namespaces

<% end %>
