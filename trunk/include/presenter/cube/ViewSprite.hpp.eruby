
<% header_guard do %>

#include "view/Sprite.hpp"
#include "presenter/cube/ViewMaster.hpp"
#include "data/ViewSpriteSetting.hpp"
#include "utils/Random.hpp"

#include "Accessors.hpp"
#include "EasingEquations.hpp"
#include "Input.hpp"
#include "Player.hpp"

#include "all_fwd.hpp"

#include <boost/lexical_cast.hpp>
#include <boost/foreach.hpp>

#include <tr1/functional>

<%= debug_include %>

namespace psc{ namespace presenter{ namespace cube{

// stupid binding would be a must,
// without it, ViewSprite, Sprite, etc. would be destroyed by GC!
// then enable_shared_from_this would be used.
class ViewSprite: public ViewBase, public std::tr1::enable_shared_from_this<ViewSprite>{
public:
    static ViewBase::pointer_type create(model::pCube cube, view::pScene scene,
        data::pMapSetting map_setting, data::pViewSpriteSetting setting, ctrl::wpPlayer const& player)
    {
        return utils::ObjectPool<ViewSprite>::create(cube, scene, map_setting, setting, player);
    }
public:
    ViewSprite(model::pCube c, view::pScene scene,
        data::pMapSetting ms, data::pViewSpriteSetting s, ctrl::wpPlayer p):
        ViewBase(c), scene_(scene), cube_(c), map_setting_(ms), setting_(s), player_(p)
    {
        body_ = view::Sprite::create("cubes/cube-item-1", scene,
                                     s->cube_size(), s->cube_size(), true);

        body_->set<accessor::Pos2D>(pos_vec2());

        restore(c->data()->color_id());
    }

    virtual void <% debug_hook 'drop_a_block' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_dropping_duration());
    }

    virtual void <% debug_hook 'sink_a_block' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_sinking_duration());
    }

    // static float rnd(){
    //     return utils::random(2) + 100;
    // }

    virtual void <% debug_hook 'drop_a_block_with_callback' do %>(callback_type callback){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_dropping_duration(), 0,
            std::tr1::bind(&ViewSprite::check_if_need_callback, shared_from_this(), callback));
    }

    virtual void <% debug_hook 'sink_a_block_with_callback' do %>(callback_type callback){ <% end %>
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_sinking_duration(), 0,
            std::tr1::bind(&ViewSprite::check_if_need_callback, shared_from_this(), callback));
        // body_->tween(data::AnimatorParam<easing::Linear, accessor::Pos2D>().
        //     end(pos_vec2()).cb(callback).speedfunc(&rnd));
    }

    virtual void <% debug_hook 'go_dying' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Alpha>(0,
            map_setting()->cube_dying_duration());
    }

    virtual void <% debug_hook 'go_exploding' do %>(){ <% end %>
        body_->clearAllTween();
        // stupid binding would be a must,
        // without it, ViewSprite, Sprite, etc. would be destroyed by GC!
        body_->tween<easing::Linear, accessor::Alpha>(0, 1000,
            0, std::tr1::bind(&ViewSprite::just_for_hold_shared_ptr, shared_from_this()) );
        body_->tween<easing::Linear, accessor::Scale>(vec3(0,0,0), 1000);
    }

    virtual void <% debug_hook 'be_broken' do %>(){ <% end %>
        body_->setTexture("cubes/cube" + to_s(utils::random(4)+1));
        shot_event(&model::Cube::restore, &model::Cube::go_exploding);
    }

    virtual void <% debug_hook 'restore' do %>(int color_id){ <% end %>
        if( color_id == -1 ) return;
        body_->setTexture("cubes/cube-item-" + to_s(color_id));
        shot_event(&model::Cube::go_exploding, &model::Cube::be_broken);
    }

    virtual void <% debug_hook 'be_garbage' do %>(){ <% end %>
        body_->setTexture("cubes/cube-b-" + to_s(utils::random(4)+1));
        shot_event(&model::Cube::go_exploding);
    }

    virtual void <% debug_hook 'hit' do %>(int /*dmg*/, int hp){ <% end %>
        body_->tween<easing::Linear, accessor::Scale>(vec3(hp/3.0,hp/3.0,hp/3.0), 500);
    }

    virtual void <% debug_hook 'get_chain' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Scale>(vec3(1.2, 1.2, 1.2), 100);
    }

    virtual void <% debug_hook 'lose_chain' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Scale>(vec3(1, 1, 1), 100);
    }

private:
    template <class MemFn>
    ViewSprite& shot_event( MemFn ally_cb, MemFn enemy_cb ) {
        using namespace std::tr1::placeholders;
        if( ctrl::pPlayer p = player_.lock() ) {
            p->subscribe_shot_event(
                std::tr1::bind( &ViewSprite::check_cube_and_do, std::tr1::mem_fn(ally_cb), cube_, _1),
                std::tr1::bind( &ViewSprite::check_cube_and_do, std::tr1::mem_fn(enemy_cb), cube_, _1)
            );
        }
        return *this;
    }
    template <class MemFn
    ViewSprite& shot_event() {
        using namespace std::tr1::placeholders;
        if( ctrl::pPlayer p = player_.lock() ) {
            p->subscribe_shot_event(
                std::tr1__bind( &ViewSprite::check_cube_and_do, std::tr1::mem_fn(ally_cb), cube_, _1),
                0);
        }
        return *this;
    }
    data::pMapSetting map_setting() const{ return map_setting_.lock(); }
    data::pViewSpriteSetting setting() const{ return setting_.lock(); }
    vec2 pos_vec2() const{
        data::pViewSpriteSetting s = setting();
        data::pCube d = data();
        return vec2( s->x_offset()+ d->x()*s->cube_size()+s->cube_size()/2,
                     s->y_offset()+(d->y()*s->cube_size()+s->cube_size()/2)*-1 );
                                                              // NOTE: reversed y
    }
    static void check_cube_and_do(std::tr1::function<void(model::pCube)> method,
        model::wpCube c)
    {
        if(model::pCube cube = c.lock()) method(cube);
    }
    void <% debug_hook 'check_if_need_callback' do %>(callback_type callback){ <% end %>
        if(model::pCube c = cube_.lock()) callback();
    }
    template <class T>
    static std::string to_s(T t){ return boost::lexical_cast<std::string>(t); }
    void just_for_hold_shared_ptr(){}

private:
    view::pSprite body_;
    view::wpScene scene_;
    model::wpCube cube_;
    data::wpMapSetting map_setting_;
    data::wpViewSpriteSetting setting_;
    ctrl::wpPlayer player_;
};

class ViewSpriteMaster: public ViewMaster{
public:
    static ViewMaster::pointer_type create(view::pScene scene, data::pViewSpriteSetting setting, ctrl::wpPlayer const& player)
    {
        return ViewMaster::pointer_type(new ViewSpriteMaster(scene, setting, player));
    }
    static ViewMaster::pointer_type create(view::pScene scene)
    {
        return create(scene, data::ViewSpriteSetting::create(), ctrl::Player::create());
    }
public:
    // no covariant return type
    virtual ViewBase::pointer_type create(model::pCube cube) const{
        return ViewSprite::create(cube, scene_.lock(), map_setting(), setting_, player_);
    }
private:
    ViewSpriteMaster(view::pScene scene, data::pViewSpriteSetting setting, ctrl::wpPlayer const& player):
        scene_(scene), setting_(setting), player_(player){}
private:
    view::wpScene scene_;
    data::pViewSpriteSetting setting_;
    ctrl::wpPlayer player_;
};

}}} // end of namespaces

<% end %>
