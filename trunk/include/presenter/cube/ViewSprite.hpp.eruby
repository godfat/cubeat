
<% header_guard do %>

#include "view/Sprite.hpp"
#include "presenter/cube/ViewMaster.hpp"
#include "data/ViewSpriteSetting.hpp"
#include "utils/Random.hpp"

#include "Accessors.hpp"
#include "EasingEquations.hpp"
#include "Input.hpp"

#include "all_fwd.hpp"

#include <tr1/functional>
#include <boost/lexical_cast.hpp>

namespace psc{ namespace presenter{ namespace cube{

// stupid binding would be a must,
// without it, ViewSprite, Sprite, etc. would be destroyed by GC!
// then enable_shared_from_this would be used.
class ViewSprite: public ViewBase, public std::tr1::enable_shared_from_this<ViewSprite>{
public:
    static ViewBase::pointer_type create(model::pCube cube, view::pScene scene,
        data::pMapSetting map_setting, data::pViewSpriteSetting setting)
    {
        return utils::ObjectPool<ViewSprite>::create(cube, scene, map_setting, setting);
    }
public:
    ViewSprite(model::pCube c, view::pScene scene,
        data::pMapSetting ms, data::pViewSpriteSetting s):
        ViewBase(c), scene_(scene), cube_(c), map_setting_(ms), setting_(s)
    {
        restore(c->data()->color_id());
    }
    virtual void drop_a_block(){
        data::pCube d = data().lock();
        int x = d->x(), y = d->y();

        data::pViewSpriteSetting s = setting();

        body_->tween<easing::Linear, accessor::Pos2D>(
            vec2( pos_x(x, s), pos_y(y, s) ), map_setting()->cube_dropping_duration()
        );
    }

    virtual void <% debug_hook 'go_dying' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Alpha>(0,
            map_setting()->cube_dying_duration());
    }

    virtual void go_exploding(){
        // stupid binding would be a must,
        // without it, ViewSprite, Sprite, etc. would be destroyed by GC!
        body_->tween<easing::Linear, accessor::Alpha>(0, 1000,
            0, std::tr1::bind(&ViewSprite::just_for_hold_shared_ptr, shared_from_this()) );
        body_->tween<easing::Linear, accessor::Scale>(vec3(0,0,0), 1000);

        // using std::tr1::cref;
        // body_->tween<easing::Linear, accessor::Alpha>(0, 1000, 0, std::tr1::bind(static_cast<
        //     view::Object& (view::Object::*) ( accessor::Scale::value_type const&,
        //                                       int unsigned const&, int const&,
        //                                       std::tr1::function<void()> const&,
        //                                       int const& ) >
        //         ( &view::Object::tween<easing::Linear, accessor::Scale> ),
        //     body_.get(), cref(vec3(0,0,0)), cref(1000), cref(0), cref(0), cref(0)) );
    }

    virtual void be_broken(){
        data::pCube d = cube_.lock()->data();
        data::pViewSpriteSetting s = setting();

        std::string path = "cubes/cube" + boost::lexical_cast<std::string>(utils::random(4)+1);        
        body_ = view::Sprite::create(path, scene_.lock(), s->cube_size(), s->cube_size());
        body_->moveTo( pos_x(d->x(), s), pos_y(d->y(), s) );
        body_->onPress( &(ctrl::Input::getInputByIndex(1)->trig1()) ) =
            std::tr1::bind( &ViewSprite::check_cube_and_do,
            std::tr1::mem_fn(&model::Cube::restore), cube_ );
    }

    virtual void restore(int color_id){
        data::pCube d = cube_.lock()->data();
        data::pViewSpriteSetting s = setting();

        std::string path = "cubes/cube-item-" + boost::lexical_cast<std::string>(color_id);
        body_ = view::Sprite::create(path, scene_.lock(), s->cube_size(), s->cube_size());

        body_->moveTo( pos_x(d->x(), s), pos_y(d->y(), s) );

        body_->onPress( &(ctrl::Input::getInputByIndex(1)->trig1()) ) =
            std::tr1::bind( &ViewSprite::check_cube_and_do,
            std::tr1::mem_fn(&model::Cube::go_exploding), cube_ );

        body_->onPress( &(ctrl::Input::getInputByIndex(1)->trig2()) ) =
            std::tr1::bind( &ViewSprite::check_cube_and_do,
            std::tr1::mem_fn(&model::Cube::be_broken), cube_ );
    }

private:
    data::pMapSetting map_setting() const{ return map_setting_.lock(); }
    data::pViewSpriteSetting setting() const{ return setting_.lock(); }
    static inline int pos_x(int x, data::pViewSpriteSetting s){
        return s->x_offset() + x*s->cube_size(); }
    static inline int pos_y(int y, data::pViewSpriteSetting s){
        return s->y_offset() + -(y*s->cube_size()); }

    static void check_cube_and_do(std::tr1::function<void(model::pCube)> method,
        model::wpCube c)
    {
        if(model::pCube cube = c.lock()) method(cube);
    }
    void just_for_hold_shared_ptr(){}

private:
    view::pSprite body_;
    view::wpScene scene_;
    model::wpCube cube_;
    data::wpMapSetting map_setting_;
    data::wpViewSpriteSetting setting_;
};

class ViewSpriteMaster: public ViewMaster{
public:
    static ViewMaster::pointer_type create(view::pScene scene, data::pViewSpriteSetting setting)
    {
        return ViewMaster::pointer_type(new ViewSpriteMaster(scene, setting));
    }
    static ViewMaster::pointer_type create(view::pScene scene)
    {
        return create(scene, data::ViewSpriteSetting::create());
    }
public:
    // no covariant return type
    virtual ViewBase::pointer_type create(model::pCube cube) const{
        return ViewSprite::create(cube, scene_.lock(), map_setting(), setting_);
    }
private:
    ViewSpriteMaster(view::pScene scene, data::pViewSpriteSetting setting):
        scene_(scene), setting_(setting){}
private:
    view::wpScene scene_;
    data::pViewSpriteSetting setting_;
};

}}} // end of namespaces

<% end %>
