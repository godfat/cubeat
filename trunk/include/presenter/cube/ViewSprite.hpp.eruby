
<% header_guard do %>

#include "view/Sprite.hpp"
#include "presenter/cube/ViewMaster.hpp"
#include "data/ViewSpriteSetting.hpp"
#include "utils/Random.hpp"

#include "Accessors.hpp"
#include "EasingEquations.hpp"
#include "Input.hpp"

#include "all_fwd.hpp"

#include <tr1/functional>
#include <boost/lexical_cast.hpp>

namespace psc{ namespace presenter{ namespace cube{

// stupid binding would be a must,
// without it, ViewSprite, Sprite, etc. would be destroyed by GC!
// then enable_shared_from_this would be used.
class ViewSprite: public ViewBase, public std::tr1::enable_shared_from_this<ViewSprite>{
public:
    static ViewBase::pointer_type create(model::pCube cube, view::pScene scene,
        data::pMapSetting map_setting, data::pViewSpriteSetting setting)
    {
        return utils::ObjectPool<ViewSprite>::create(cube, scene, map_setting, setting);
    }
public:
    ViewSprite(model::pCube c, view::pScene scene,
        data::pMapSetting ms, data::pViewSpriteSetting s):
        ViewBase(c), scene_(scene), cube_(c), map_setting_(ms), setting_(s)
    {
        restore(c->data()->color_id());
    }
    virtual void drop_a_block(){
        body_->tween<easing::Linear, accessor::Pos2D>(
            pos_vec2(), map_setting()->cube_dropping_duration());
    }

    virtual void <% debug_hook 'go_dying' do %>(){ <% end %>
        body_->tween<easing::Linear, accessor::Alpha>(0,
            map_setting()->cube_dying_duration());
    }

    virtual void go_exploding(){
        // stupid binding would be a must,
        // without it, ViewSprite, Sprite, etc. would be destroyed by GC!
        body_->tween<easing::Linear, accessor::Alpha>(0, 1000,
            0, std::tr1::bind(&ViewSprite::just_for_hold_shared_ptr, shared_from_this()) );
        body_->tween<easing::Linear, accessor::Scale>(vec3(0,0,0), 1000);

        // using std::tr1::cref;
        // body_->tween<easing::Linear, accessor::Alpha>(0, 1000, 0, std::tr1::bind(static_cast<
        //     view::Object& (view::Object::*) ( accessor::Scale::value_type const&,
        //                                       int unsigned const&, int const&,
        //                                       std::tr1::function<void()> const&,
        //                                       int const& ) >
        //         ( &view::Object::tween<easing::Linear, accessor::Scale> ),
        //     body_.get(), cref(vec3(0,0,0)), cref(1000), cref(0), cref(0), cref(0)) );
    }

    virtual void be_broken(){
        create_sprite("cubes/cube" + to_s(utils::random(4)+1));

        on_press( &(ctrl::Input::getInputByIndex(1)->trig1()),
            &model::Cube::restore );
    }

    virtual void restore(int color_id){
        create_sprite("cubes/cube-item-" + to_s(color_id));

        on_press( &(ctrl::Input::getInputByIndex(1)->trig1()),
            &model::Cube::go_exploding );

        on_press( &(ctrl::Input::getInputByIndex(1)->trig2()),
            &model::Cube::be_broken );
    }

    virtual void be_garbage(){
        create_sprite("cubes/cube-b-" + to_s(utils::random(4)+1));

        on_press( &(ctrl::Input::getInputByIndex(1)->trig1()),
            &model::Cube::go_exploding );
    }

    virtual void hit(int /*dmg*/, int hp){
        body_->tween<easing::Linear, accessor::Scale>(vec3(hp/3.0,hp/3.0,hp/3.0), 500);
    }

private:
    template <class MemFn>
    ViewSprite& on_press( ctrl::Button const* btn, MemFn mem_fn ){
        body_->onPress( btn ) =
            std::tr1::bind( &ViewSprite::check_cube_and_do,
            std::tr1::mem_fn(mem_fn), cube_ );
        return *this;
    }
    ViewSprite& create_sprite(std::string const& path){
        last_pos_ = body_ ? body_->get<accessor::Pos2D>() : pos_vec2();

        data::pViewSpriteSetting s = setting();
        body_ = view::Sprite::create(path, scene_.lock(),
                                     s->cube_size(), s->cube_size(), true);
        adjust();
        return *this;
    }
    ViewSprite& adjust(){
        // vec2 pos = pos_vec2();
        body_->moveTo(last_pos_.X, last_pos_.Y); // NOTE: irr related...
        // drop_a_block();
        return *this;
    }
    data::pMapSetting map_setting() const{ return map_setting_.lock(); }
    data::pViewSpriteSetting setting() const{ return setting_.lock(); }
    vec2 pos_vec2() const{
        data::pViewSpriteSetting s = setting();
        data::pCube d = data();
        return vec2( s->x_offset()+ d->x()*s->cube_size()+s->cube_size()/2,
                     s->y_offset()+(d->y()*s->cube_size()+s->cube_size()/2)*-1 );
                                                              // NOTE: reversed y
    }
    static void check_cube_and_do(std::tr1::function<void(model::pCube)> method,
        model::wpCube c)
    {
        if(model::pCube cube = c.lock()) method(cube);
    }
    template <class T>
    static std::string to_s(T t){ return boost::lexical_cast<std::string>(t); }
    void just_for_hold_shared_ptr(){}

private:
    view::pSprite body_;
    view::wpScene scene_;
    model::wpCube cube_;
    data::wpMapSetting map_setting_;
    data::wpViewSpriteSetting setting_;

    vec2 last_pos_;
};

class ViewSpriteMaster: public ViewMaster{
public:
    static ViewMaster::pointer_type create(view::pScene scene, data::pViewSpriteSetting setting)
    {
        return ViewMaster::pointer_type(new ViewSpriteMaster(scene, setting));
    }
    static ViewMaster::pointer_type create(view::pScene scene)
    {
        return create(scene, data::ViewSpriteSetting::create());
    }
public:
    // no covariant return type
    virtual ViewBase::pointer_type create(model::pCube cube) const{
        return ViewSprite::create(cube, scene_.lock(), map_setting(), setting_);
    }
private:
    ViewSpriteMaster(view::pScene scene, data::pViewSpriteSetting setting):
        scene_(scene), setting_(setting){}
private:
    view::wpScene scene_;
    data::pViewSpriteSetting setting_;
};

}}} // end of namespaces

<% end %>
