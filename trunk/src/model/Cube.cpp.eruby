
#include "model/Cube.hpp"
#include "model/Chain.hpp"
#include "model/state/State.hpp"
#include "model/state/Waiting.hpp"
#include "model/state/Exploding.hpp"
#include "model/state/Dropping.hpp"
#include "model/state/Dying.hpp"

#include "all_fwd.hpp"

<%= debug_include %>

using namespace psc;
using namespace model;
using namespace state;
using std::tr1::dynamic_pointer_cast;

bool <% debug_hook 'Cube::cycle_and_die' do %>(){
<% end %>
    if(state_) state_->cycle();
    return is_dead();
}

void <% debug_hook 'Cube::be_garbage' do %>(){
<% end %>
    is_garbage_ = true;
	hp_ = 1;
    color_id(-1); // = data::Color::random_rgb_color();
    be_garbage_event()();
}

// begin only used by Map::next_state
pWaiting Cube::is_waiting(){ return dynamic_pointer_cast<Waiting>(state_); }
pDropping Cube::is_dropping(){ return dynamic_pointer_cast<Dropping>(state_); }
pDying const Cube::is_dying() const{ return dynamic_pointer_cast<Dying>(state_); }
// pExploding const Cube::is_exploding() const{ return dynamic_pointer_cast<Exploding>(state_); }

void <% debug_hook 'Cube::drop_a_block' do %>(){
<% end %>
    // --y_;
    y(y()-1);
    drop_a_block_event()();
}

void <% debug_hook 'Cube::lose_chain_without_event' do %>(){
<% end %>
	chain_belonged_to_.reset();
}

void <% debug_hook 'Cube::lose_chain' do %>(){
<% end %>
    if( map()->cube_can_lose_chain(shared_from_this()) ){
        lose_chain_without_event();
        lose_chain_event()();
    }
}
// end

// only used by OneFading::fade
void <% debug_hook 'Cube::go_dying' do %>(){
<% end %>
    state_ = state::Dying::create(shared_from_this());
    go_dying_event()();
}

void <% debug_hook 'Cube::go_exploding' do %>(){
<% end %>
    // state_ = state::Exploding::create(shared_from_this());
    if( is_dying() )
        return; // don't explode me while i am dying!!

    else if(--hp_ > 0)
        hit_event()(1, hp_); // damgage, hp left

    else{
        state_.reset();
        go_exploding_event()();
    }
}

void <% debug_hook 'Cube::be_broken' do %>(){
<% end %>
    if( is_dying() ) return;

	is_broken_ = true;
    color_id(-1); // = data::Color::random_rgb_color();
    be_broken_event()();
}

void <% debug_hook 'Cube::restore' do %>(){
<% end %>
    is_broken_ = false;
    color_id(utils::random(map()->ms()->color_amounts())+1);
    if( state::pWaiting w = is_waiting() )
        w->uncheck();
    restore_event()(color_id());
}
