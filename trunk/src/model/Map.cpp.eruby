
#include "model/detail/MapUtils.hpp"

#include "presenter/Map.hpp"
#include "presenter/Cube.hpp"
#include "model/Map.hpp"
#include "model/Cube.hpp"
#include "model/OneFading.hpp"
#include "model/state/Waiting.hpp"
#include "model/state/Dropping.hpp"
#include "model/state/Dying.hpp"

#include "utils/ChainChecker.hpp"
#include "utils/for_each_multi_array.hpp"
#include "utils/vector_2d.hpp"

#include <boost/lambda/lambda.hpp>
#include <algorithm>

<%= debug_include %>

using namespace psc;
using namespace model;
using detail::check_not_continue;
using detail::process_chaining;
using namespace std::tr1::placeholders;

Map& <% debug_hook 'Map::init_cubes' do %>(){
<% end %>
    using boost::lambda::_1; // this would be used in for_each for element
    using boost::lambda::_2; // this would be used in for_each for index
    int width = ms()->width(); //, height = ms()->height();
    utils::vector_2d cube_colors(boost::extents[width][ms()->starting_line()]);

    int const one_color_amounts = std::ceil(
        static_cast<double>(width)*ms()->starting_line()/ms()->color_amounts()
    );
    utils::for_each(cube_colors, _1 = _2/one_color_amounts + 1);

    // utils::ChainChecker::until_no_chained_cubes(cube_colors, ms()->chain_amounts());

    presenter::pMap owner = owner_.lock();
    for(int i=0, iend=cube_colors.num_elements(); i!=iend; ++i)
    {
        int x = i%width, y = i/width;
        insert_cube( owner->make_cube(x, y, cube_colors[x][y])->model() );
    }

	fill_preview_queue(); // added

    return *this;
}

void <% debug_hook 'Map::refresh_cubes' do %>(){
<% end %>
    utils::for_each_ignore_null(cubes_, std::tr1::bind(&Cube::refresh, _1));
}

void <% debug_hook 'Map::cycle_cubes' do %>(){
<% end %>
    n_of_newcomers_ = 0;
    utils::for_each_ignore_null(cubes_, std::tr1::bind(&Map::cycle_a_cube, this, _1, _2));
}

void <% debug_hook 'Map::cycle_a_cube' do %>(pCube c, int i){
<% end %>
    if( !c->has_grounded()  ) ++n_of_newcomers_;
    if(  c->cycle_and_die() ) cubes_.origin()[i].reset(), owner_.lock()->release(c);
}

Map& <% debug_hook 'Map::insert_cube' do %>(pCube cube){
<% end %>
    cubes_[cube->x()][cube->y()] = cube;
    return *this;
}
Map& <% debug_hook 'Map::insert_garbage' do %>(pCube cube){
<% end %>
    cube->be_garbage();
    return insert_cube(cube);
}

Map& <% debug_hook 'Map::insert_preview' do %>(pCube cube){
<% end %>
    cubes_preview_.push_back(cube);
    return *this;
}

// used by Dropping::cycle, Waiting::cycle
state::pState <% debug_hook 'Map::next_state' do %>(pCube that){
<% end %>
    if( state::pWaiting waiting = that->is_waiting() ){

		if( waiting->need_check() ){
            pOneFading one_fading = make_OneFading(that);

            if( one_fading ){
                one_fading->fade(that);
                return state::Dying::create(that);
            }
            waiting->checked();
			that->set_grounded(); // once grounded, always grounded
        }
		if( waiting->need_check_chain_property() ){
			if( cube_can_lose_chain(that) )
	            that->lose_chain();
			waiting->chain_property_checked();
		}
    }

    if( is_below_empty(that) ){
        cubes_[that->x()][that->y()].reset();
        that->drop_a_block();
        cubes_[that->x()][that->y()] = that;
        if( that->is_dropping() )
            return state::pState();
        else
            return state::Dropping::create(that);
    }
    else{
        if( that->is_waiting() )
            return state::pState();
		else{
			// Sound::i().cube_dropped();
            return state::Waiting::create(that);
		}
    }
    // throw "impossible flow";
    return state::pState();
}

// resolve the chain on the cube
void <% debug_hook 'Map::cubes_belong_to_the_chain_from_bottom_to_top' do %>(pCube that, pChain chain){
<% end %>
    for(int x=that->x(), y=that->y();
		cubes_[x][y].use_count() != 0 &&
		cubes_[x][y]->is_waiting() &&
        cubes_[x][y]->chain() == chain
		; ++y)
    {
        cubes_[x][y]->lose_chain_delay() = 0;
    }

    // start chainging
	for(int x=that->x(), y=that->y();
        cubes_[x][y].use_count() != 0 &&
        cubes_[x][y]->is_waiting() && // added: important
		cubes_[x][y]->chain().use_count() == 0 // added: important
		; ++y)
    {
        cubes_[x][y]->chain(chain);
		// cubes_[x][y]->show_outline();
        cubes_[x][y]->lose_chain_delay() = 0;
        chain->inc_one_owner();
    }
}

// create a row of chaining cubes,
// not_traveled indicates that cubes we need to search;
// result indicates that cubes were successfully built
void <% debug_hook 'Map::make_row' do %>(pCube that, cube_list_type& not_traveled, cube_list_type& result){
<% end %>
    std::vector<pCube> row;

    for(int i=that->x(); i>=0; --i) // include self
        if( check_not_continue( row, that, cubes_[i][that->y()] ) )
            break;

    for(int i=that->x()+1, iend=ms()->width(); i!=iend; ++i) // exclude self
        if( check_not_continue( row, that, cubes_[i][that->y()] ) )
            break;

    if(static_cast<int>(row.size()) >= ms()->chain_amounts())
        process_chaining(row, not_traveled, result);
}

// same as make_row, but column instead.
void <% debug_hook 'Map::make_column' do %>(pCube that, cube_list_type& not_traveled, cube_list_type& result){
<% end %>
    std::vector<pCube> column;

    for(int i=that->y(); i>=0; --i) // include self
        if( check_not_continue( column, that, cubes_[that->x()][i] ) )
            break;

    for(int i=that->y()+1, iend=ms()->height(); i!=iend; ++i) // exclude self
        if( check_not_continue( column, that, cubes_[that->x()][i] ) )
            break;

    if(static_cast<int>(column.size()) >= ms()->chain_amounts())
        process_chaining(column, not_traveled, result);
}

// create a cube list that we need for one fading.
// traveld indicates that the cubes we traveled through the process;
// not_traveled indicates that the cubes we should travel through the process;
// result would contain the cubes we need to build one fading.
void <% debug_hook 'Map::make_clist' do %>(cube_list_type& traveled, cube_list_type& not_traveled, cube_list_type& result){
<% end %>
    if(not_traveled.size()){
        cube_list_type::iterator node = not_traveled.begin();
        pCube cube = *node;

        if( traveled.count(cube) == 0 ){
            make_row(cube, not_traveled, result);
            make_column(cube, not_traveled, result);
            traveled.insert(cube);
        }

        not_traveled.erase(node);

        make_clist(traveled, not_traveled, result);
    }
}

// create a one fading through that cube,
// find the cubes in this one fading with make_clist
pOneFading <% debug_hook 'Map::make_OneFading' do %>(pCube that){
<% end %>
    cube_list_type traveled, not_traveled, result;
    not_traveled.insert(that);
    make_clist(traveled, not_traveled, result);
    return result.size() ? OneFading::create(*this, result) : pOneFading();
}

bool <% debug_hook 'Map::is_below_empty' do %>(cpCube that) const{
<% end %>
    if( that->y() == 0 ) return false;
    else return cubes_[that->x()][that->y()-1].use_count() == 0;
    // throw "impossible flow!";
    return false;
}

// all cubes share the same column with that lose the chain
bool <% debug_hook 'Map::cube_can_lose_chain' do %>(cpCube that) const{
<% end %>
	for( int x = that->x(), y = that->y()-1; y >= 0; --y )
	    if( cubes_[x][y].use_count() == 0 ||
	        cubes_[x][y]->is_dying() || cubes_[x][y]->is_exploding() ) 
	    {
	        // when it's empty, dying or exploding, the square ontop can't lose chain
	        return false;
	    }
	return true;
}

void <% debug_hook 'Map::update_chains' do %>(){
<% end %>
    for(chain_list_type::iterator i=chains_.begin();
        i != chains_.end(); ++i)
    {
        // when the Chain's rear is not zero we notify to add a new combo
        if( (**i).last_step_amounts() != 0 ){
        // damage_factor to score adjustment (1.00 ~ 2.00)
            score_ += (**i).score_step() * ms()->damage_factor();
            (**i).step_one();
        }

        // when the Chain's all dead then we fire up the attack and make this one null
        if( (**i).owner_amounts() == 0 ){
            // damage_factor to score adjustment (1.00 ~ 2.00)
            // SG::Instance().make_garbage( this, (**i).power_factor() * ms().damage_factor );
            i = chains_.erase(i);
            --i;
        }
    }
}

void <% debug_hook 'Map::cycle_creation_garbage' do %>(){
<% end %>
    // no garbage no working
	if( garbage_left_ <= 0 || ( n_of_newcomers_ > 0 && garbage_switch_ == false ) ){
    // if( garbage_left_ <= 0 || n_of_newcomers_ > 0 ){
		garbage_switch_ = false;
        return;
	}

	garbage_switch_ = true;

    std::vector<int> is_empty;

	// check empty columns
	for( int x=0, width=ms()->width(); x < width; ++x )
		if( !cubes_[x][0] && !cubes_[x][1] )
			is_empty.push_back( x );

	// shuffle the array
    std::random_shuffle(is_empty.begin(), is_empty.end());

	// drop them according to the empty column
    presenter::pMap owner = owner_.lock();
    int top = ms()->height()-1;
	for( int unsigned i=0; i < is_empty.size() && garbage_left_ > 0 ; ++i ){
        int x = is_empty[i];
		insert_garbage( owner->make_cube(x, top)->model() );
		--garbage_left_;
	}
}

void <% debug_hook 'Map::cycle_creation' do %>(){
<% end %>
    if( garbage_left_ > 0 || n_of_newcomers_ > 0 || garbage_switch_ == true )
		return;

	// we must check which column's top is empty when drop squares
	// so we setup an array of columns which its top is empty
    int top = ms()->height()-1;
	std::vector<int> is_empty;
	for( int x=0, width = ms()->width(); x < width; ++x )
		if( !cubes_[x][top] && !cubes_[x][top-1] )
			is_empty.push_back( x );

	if( is_empty.size() == 0 ) return;

    for(std::vector<int>::const_iterator i=is_empty.begin(), iend=is_empty.end();
        i!=iend; ++i)
    {
        int x = *i;
        cubes_preview_[x]->x(x).y(top);
        insert_cube(cubes_preview_[x]);
    }

    fill_preview_queue();

    // if( SG::Instance().game_mode() == 1 ) // if single
    //  garbage_left_ += SG::Instance().random(3);
}

void <% debug_hook 'Map::fill_preview_queue' do %>(){
<% end %>
	cubes_preview_.clear();
    int width = ms()->width();
	std::vector<int> preview_set( width ); // color set
	int count = 0;
	if( utils::random(2) ){
		preview_set[0] = preview_set[1] = utils::random( ms()->color_amounts() )+1;
		count = 1;
	} else preview_set[0] = utils::random( ms()->color_amounts() )+1;

    for( int cend = width-1; count != cend; ){
		if( count == cend-1 ) fill_preview1( preview_set, count );
		else{
			if( utils::random(2) ) fill_preview2( preview_set, count );
			else                   fill_preview1( preview_set, count );
		}
	}

    presenter::pMap owner = owner_.lock();
	for( int x=0; x != width ; ++x )
        cubes_preview_.push_back( owner->make_cube_preview(preview_set[x])->model() );
}

void <% debug_hook 'Map::fill_preview1' do %>(std::vector<int>& preview_set, int& count){
<% end %>
	++count; // add length 1 here
	int temp, color_amounts = ms()->color_amounts();
	do{
		temp = utils::random( color_amounts )+1; 
	}while( temp == preview_set[ count-1 ] );
    preview_set[ count ] = temp;
}

void <% debug_hook 'Map::fill_preview2' do %>(std::vector<int>& preview_set, int& count){
<% end %>
    count += 2; // add length 2 here
    int temp, color_amounts = ms()->color_amounts();
	do{
		temp = utils::random( color_amounts )+1;
	}while( temp == preview_set[ count-2 ] );
	preview_set[ count-1 ] = preview_set[ count ] = temp;
}

Map::color_map_type <% debug_hook 'Map::color_map' do %>() const{
<% end %>
    int width = ms()->width(), height = ms()->height();
    color_map_type result(boost::extents[width][height]);
    for(int y=0; y<height; ++y)
        for(int x=0; x<width; ++x)
            if(cubes_[x][y])
                result[x][y] = cubes_[x][y]->color_id();
    return result;
}

// added: split warning check from cycle_creation:
void <% debug_hook 'Map::cycle_warning' do %>(){
<% end %>
/*
    EventDispatcher::i().subscribe_timer(cycle_warning, 1500);
    if( check_column_full() )
        switch(counting_num_){
            case -1: game over; break;
            default: --counting_num_, yell warning, count down; break;
        }

    else
        counting_num_ = 4, no warning;
*/
    if( ++warning_check_step_ > ms()->warning_check_delay() ){
		if( check_column_full() ){ // warning!!!
			if( lose_warning_step_ == 0 ){
				counting_num_ = 4;
                lose_warning_step_ = std::time(0);
            }
			if( counting_num_ >= 0 ){
				// SG::Instance().yell_warning(this, counting_num );
				--counting_num_;
				// Sound::i().countdown();
			}
			else ;// SG::Instance().game_over(this);
        }
        else{
            // SG::Instance().no_warning(this);
            lose_warning_step_ = 0;
        }
		warning_check_step_ = 0;
	}
}

bool <% debug_hook 'Map::check_column_full' do %>() const{
<% end %>
	int counter = 0;
	for( int x=0, width = ms()->width(), y = ms()->height()-2; x < width; ++x ){
		if( cubes_[x][y] && cubes_[x][y]->is_waiting() ){
			++counter;
			// warning_strip_[xx]->Show(CKSHOW);
		}
		else ;// warning_strip_[xx]->Show(CKHIDE);
	}

    return counter > 0;
}
