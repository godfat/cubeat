
#include "model/Map.hpp"
#include "model/Cube.hpp"
#include "model/state/Waiting.hpp"
#include "model/state/Dropping.hpp"
#include "model/state/Dying.hpp"

#include "utils/ChainChecker.hpp"
#include "utils/for_each_multi_array.hpp"
#include "utils/vector_2d.hpp"

#include <boost/lambda/lambda.hpp>

<%= debug_include %>

using namespace psc;
using namespace model;

Map& <% debug_hook 'Map::init_cubes' do %>(){
<% end %>
    using boost::lambda::_1; // this would be used in for_each for element
    using boost::lambda::_2; // this would be used in for_each for index
    utils::vector_2d cube_colors(boost::extents[ms()->width()][ms()->starting_line()]);

    int const one_color_amounts = std::ceil(
        static_cast<double>(ms()->width())*ms()->starting_line()/ms()->color_amounts()
    );
    utils::for_each(cube_colors, _1 = _2/one_color_amounts);

    utils::ChainChecker::until_no_chained_cubes(cube_colors, ms()->chain_amounts());

    for(int i=0, iend=cube_colors.num_elements(); i!=iend; ++i)
    {
        insert(owner_.lock()->make_cube( i%ms()->width(), // x
                                         ms()->height()-1-i/ms()->width(), // y
                                         cube_colors.origin()[i] )->model());
    }
    return *this;
}

void <% debug_hook 'Map::do_cycle' do %>(pCube c, int i){
<% end %>
    if(c){
        if( !c->has_grounded()  ) ++n_of_newcomers_;
        if(  c->cycle_and_die() ) cubes_.origin()[i].reset();
    }
}

Map& <% debug_hook 'Map::insert' do %>(pCube cube){
<% end %>
    cubes_[cube->x()][cube->y()] = cube;
    return *this;
}

// used by Dropping::cycle, Waiting::cycle
state::pState <% debug_hook 'Map::next_state' do %>(pCube that){
<% end %>
    if( state::pWaiting waiting = that->is_waiting() ){

		if( waiting->need_check() ){
            pOneFading one_fading = make_OneFading(that);

            if( one_fading != NULL ){
                one_fading->fade(that);
                return state::Dying::create()->init(that)->init2();
            }
            waiting->checked();
			that->set_grounded(); //once grounded, always grounded
        }
		if( waiting->need_check_chain_property() ){
			if( cube_can_lose_chain(that) ) { 
	            that->lose_chain();
				if( !that->is_garbage() )
				    that->hide_outline();
			}
			waiting->chain_property_checked();
		}
    }

    if( is_below_empty(that) ){
        data_.at(that->x(), that->y()) = NULL;
        that->drop_a_block();
        data_.at(that->x(), that->y()) = that;
        if( that->is_dropping() )
            return NULL;
        else
            return state::Dropping::create(that);
    }
    else{
        if( that->is_waiting() )
            return NULL;
		else {
			// Sound::i().cube_dropped();
            return state::Waiting::create(that);
		}
    }
    // throw "impossible flow";
    return NULL;
}
