
#include "presenter/Cube.hpp"
#include "presenter/Map.hpp"
#include "model/Map.hpp"

#include "view/Scene.hpp"
#include "view/SpriteText.hpp"
#include "EasingEquations.hpp"
#include "Accessors.hpp"
#include "Sound.hpp"

#include "all_fwd.hpp"
#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>

<%= debug_include %>

using namespace psc;
using namespace presenter;

Map& <% debug_hook 'Map::call_end_game' do %>(){
<% end %>
    std::cout << "presenter map call end game.\n";
    return *this;
}

Map& <% debug_hook 'Map::setup_warning' do %>(){
<% end %>
    std::cout << "presenter map setup_warning.\n";
    return *this;
}

Map& <% debug_hook 'Map::take_out_warning' do %>(){
<% end %>
    std::cout << "presenter map take_out_warning.\n";
    return *this;
}

Map& <% debug_hook 'Map::show_chain' do %>(int combo, int idx){
<% end %>
    std::cout << "chain: " << idx << " ,combo " << combo << "\n";
    std::string str("Chain "), numstr( boost::lexical_cast<std::string>(combo) );
    str += numstr;
    view::pScene s = view_master_->scene();
    view::pSpriteText chain_outl = view::SpriteText::create(str, s, "Star Jedi", 35 + combo*5, true, data::Color(255,0,0));
    view::pSpriteText chain_text = view::SpriteText::create(str, s, "Star Jedi", 35 + combo*5, true);
    chain_outl->setDepth(-50).set<accessor::Pos2D>( vec2(setting()->centerx()+1, 199 + idx*40) );
    chain_text->setDepth(-60).set<accessor::Pos2D>( vec2(setting()->centerx(), 200 + idx*40) );
    Sound::i().play( ("2/2b_" + numstr) + ".mp3");

    //let it bind and make copy to preserve tween
    chain_outl->tween<easing::OElastic, accessor::Scale>
        (vec3(0,0,0), vec3(1.03,1.15,1), 500, 0, std::tr1::bind(&view::SpriteText::changeText, chain_outl, ""));
    chain_text->tween<easing::OElastic, accessor::Scale>
        (vec3(0,0,0), vec3(1,1,1), 500, 0, std::tr1::bind(&view::SpriteText::changeText, chain_text, ""));
    return *this;
}

Map& <% debug_hook 'Map::push_view_slave' do %>(cube::pViewMaster view){
<% end %>
    view->map_setting(setting());

    typedef std::pair<model::wpCube, pCube> cube_pair_type; // macro workaround
    BOOST_FOREACH(cube_pair_type cube_pair, cubes_){
        pCube cube = cube_pair.second;
        cube->push_view_slave( view->create(cube->model()) );
    }
    view_slaves_.push_back(view);
    return *this;
}

Map& <% debug_hook 'Map::set_view_master' do %>(cube::pViewMaster view){
<% end %>
    view->map_setting(setting());

    typedef std::pair<model::wpCube, pCube> cube_pair_type; // macro workaround
    BOOST_FOREACH(cube_pair_type cube_pair, cubes_){
        pCube cube = cube_pair.second;
        cube->set_view_master( view->create(cube->model()) );
    }
    view_master_ = view;
    return *this;
}

pMap <% debug_hook 'Map::init' do %>(){
<% end %>
    pMap self = shared_from_this();
    model_ = model::Map::create(self, setting_);
    model_->init_cubes(); // beware! this need refer model_!
    return self;
}

pMap <% debug_hook 'Map::init' do %>(utils::vector_2d<int> const& data){		
<% end %>		
    pMap self = shared_from_this();		
    model_ = model::Map::create(self, setting_);		
    model_->init_cubes(data); // beware! this need refer model_!

    return self;
}

void <% debug_hook 'Map::bind_cube_event' do %>(pCube cube){
<% end %>
    using namespace std::tr1::placeholders;
    cube->model()->    go_dying_event( std::tr1::bind( &Cube::go_dying, cube.get() ) ).
                   go_exploding_event( std::tr1::bind( &Cube::go_exploding, cube.get() ) ).
                     be_garbage_event( std::tr1::bind( &Cube::be_garbage, cube.get() ) ).
                      be_broken_event( std::tr1::bind( &Cube::be_broken, cube.get() ) ).
                        restore_event( std::tr1::bind( &Cube::restore, cube.get(), _1) ).
                            hit_event( std::tr1::bind( &Cube::hit, cube.get(), _1, _2 ) ).
                      get_chain_event( std::tr1::bind( &Cube::get_chain, cube.get() ) ).
                     lose_chain_event( std::tr1::bind( &Cube::lose_chain, cube.get() ) ).
                   drop_a_block_event( std::tr1::bind( &Cube::drop_a_block, cube.get() ) ).
                   sink_a_block_event( std::tr1::bind( &Cube::sink_a_block, cube.get() ) );
}

pCube <% debug_hook 'Map::make_cube' do %>(int x, int y, int color_id){
<% end %>
    pCube cube = Cube::create(shared_from_this(), x, y, color_id);
    bind_cube_event(cube);
    BOOST_FOREACH(cube::pViewMaster& view, view_slaves_){
        cube->push_view_slave( view->create(cube->model()) );
    }
    if(view_master_) cube->set_view_master( view_master_->create(cube->model()) );
    cubes_.insert(std::make_pair(cube->model(), cube));
    return cube;
}

pCube <% debug_hook 'Map::make_cube_preview' do %>(int color_id){
<% end %>
    return make_cube(-1, -1, color_id);
}

Map& <% debug_hook 'Map::cycle' do %>(){
<% end %>
    model()->cycle_slow();
    model()->cycle_fast();
    return *this;
}

Map& <% debug_hook 'Map::cycle_slow' do %>(){
<% end %>
    model()->cycle_slow();
    return *this;
}

Map& <% debug_hook 'Map::cycle_fast' do %>(){
<% end %>
    model()->cycle_fast();
    return *this;
}
